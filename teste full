local switchCombo = "comboButton"

if not storage[switchCombo] then
    storage[switchCombo] = { enabled = false }
end

local comboButton = setupUI([[
Panel
  height: 20
  margin-top: -3
  BotSwitch
    id: title
    anchors.top: parent.top
    anchors.left: parent.left
    text-align: center
    width: 110
    text: AttackBot
    font: verdana-9px
    color: white
    image-source: /images/ui/button_rounded
    $on:
      font: verdana-9px
      color: green

  Button
    id: settings
    anchors.top: prev.top
    anchors.left: prev.right
    anchors.right: parent.right
    margin-left: 0
    height: 17
    text: Config
    font: verdana-9px
    image-source: /images/ui/button_rounded
]])
comboButton:setId(switchCombo)
comboButton.title:setOn(storage[switchCombo].enabled)

comboButton.title.onClick = function(widget)
    local newState = not widget:isOn()
    widget:setOn(newState)
    storage[switchCombo].enabled = newState
end

comboInterface = setupUI([[
UIWindow
  id: mainPanel
  size: 400 360
  border: 1 black
  anchors.centerIn: parent
  margin-top: -60

  Panel
    id: background
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    background-color: black
    opacity: 0.70

  Panel
    id: topPanel
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    size: 120 30
    text-align: center
    !text: tr('LNS SCRIPT-BOT')
    color: orange
    margin-left: 0
    margin-right: 0
    background-color: black
    $hover:
      image-color: gray
  
  Panel
    id: iconPanel
    anchors.top: parent.top
    anchors.left: parent.left
    size: 60 60
    margin-top: -19
    margin-left: -15

  UIButton
    id: closePanel
    anchors.top: topPanel.top
    anchors.right: parent.right
    size: 18 18
    margin-top: 6
    margin-right: 10
    background-color: orange
    text: X
    color: white
    opacity: 1.00
    $hover:
      color: black
      opacity: 0.80

  FlatPanel
    id: panelMain
    anchors.top: prev.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: 18
    margin-right: 8
    margin-left: 8
    height: 160
    image-color: #363636
    layout: verticalBox

  Label
    id: labelHealing
    anchors.top: prev.top
    anchors.left: panelMain.left
    text: CONFIGURATION SPELLS:
    text-auto-resize: true
    font: verdana-9px-italic
    margin-top: -5
    margin-left: 10

  BotSwitch
    id: offHealing
    anchors.top: prev.top
    anchors.left: prev.right
    image-souce: /images/ui/button_rounded
    image-color: #363636
    margin-left: 5
    margin-top: -3
    width: 60
    $!on
      opacity: 0.70
      image-color: #363636
      text: OFFLINE
      color: red
    $on:
      opacity: 1.00
      color: #7CFC00
      text: ONLINE
      image-color: #363636
      
  TextList
    opacity: 1.00
    id: spellList
    anchors.left: panelMain.left
    anchors.right: panelMain.right
    anchors.top: labelHealing.bottom
    padding: 1
    height: 120 
    margin-top: 5
    margin-left: 5
    margin-right: 17
    vertical-scrollbar: spellListScrollBar
    image-color: #363636

  VerticalScrollBar
    id: spellListScrollBar
    anchors.top: spellList.top
    anchors.bottom: spellList.bottom
    anchors.left: spellList.right
    step: 10
    pixels-scroll: true
    visible: true
    image-color: #363636
    opacity: 0.90

  Button
    id: adicionarSpell
    anchors.left: spellList.left
    anchors.top: spellList.bottom
    image-source: /images/ui/button_rounded
    size: 80 25
    margin-top: 2
    image-color: #363636
    text: Add Spell
    font: verdana-11px-rounded
    color: gray

  Button
    id: adicionarRuna
    anchors.left: adicionarSpell.right
    anchors.top: spellList.bottom
    image-source: /images/ui/button_rounded
    size: 80 25
    margin-top: 2
    image-color: #363636
    text: Add Rune
    font: verdana-11px-rounded
    color: gray

  Button
    id: moveUp
    anchors.right: spellListScrollBar.right
    anchors.top: spellList.bottom
    image-source: /images/ui/button_rounded
    size: 25 25
    margin-top: 2
    image-color: #363636
    text: /\
    font: verdana-11px-rounded
    color: gray

  Button
    id: moveDown
    anchors.right: moveUp.left
    anchors.top: spellList.bottom
    image-source: /images/ui/button_rounded
    size: 25 25
    margin-top: 2
    image-color: #363636
    text: \/
    font: verdana-11px-rounded
    color: gray

  FlatPanel
    id: panelTools
    anchors.top: panelMain.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: 8
    margin-right: 8
    margin-left: 8
    height: 60
    image-color: #363636
    layout: verticalBox

  Label
    id: labelTools
    anchors.top: prev.top
    anchors.left: panelMain.left
    text: CONFIG ATTACKER:
    text-auto-resize: true
    font: verdana-9px-italic
    margin-top: -5
    margin-left: 10


  CheckBox
    id: virarTarget
    anchors.top: labelTools.bottom
    anchors.left: labelTools.left
    text: Virar Target
    text-auto-resize: true
    font: verdana-11px-rounded
    color: gray
    image-source: /images/ui/checkbox_round
    margin-top: 10

  CheckBox
    id: manterDist
    anchors.top: prev.bottom
    anchors.left: prev.left
    text: Manter Distancia
    text-auto-resize: true
    font: verdana-11px-rounded
    image-source: /images/ui/checkbox_round
    color: gray
    margin-top: 10

  FlatPanel
    id: panelSafe
    anchors.top: panelTools.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: 8
    margin-right: 8
    margin-left: 8
    height: 80
    image-color: #363636
    layout: verticalBox

  Label
    id: labelSafe
    anchors.top: prev.top
    anchors.left: panelMain.left
    text: SAFE ZONE:
    text-auto-resize: true
    font: verdana-9px-italic
    margin-top: -5
    margin-left: 10
      
  CheckBox
    id: CheckStairs
    anchors.top: labelSafe.bottom
    anchors.left: labelSafe.left
    text: Checar Stairs
    text-auto-resize: true
    font: verdana-11px-rounded
    image-source: /images/ui/checkbox_round
    color: gray
    margin-top: 10

  Panel
    id: idsSafeAndares
    anchors.top: prev.top
    anchors.left: CheckStairs.right
    margin-top: -10
    margin-left: 13
    size: 250 35

  CheckBox
    id: IgnoreParty
    anchors.top: CheckStairs.bottom
    anchors.left: CheckStairs.left
    text: Checar Players
    text-auto-resize: true
    font: verdana-11px-rounded
    image-source: /images/ui/checkbox_round
    color: gray
    margin-top: 10

  CheckBox
    id: stopOnPk
    anchors.top: prev.bottom
    anchors.left: prev.left
    text: OFF PK/Frags
    text-auto-resize: true
    font: verdana-11px-rounded
    image-source: /images/ui/checkbox_round
    color: gray
    margin-top: 10

  Label
    id: labelSqm
    anchors.top: prev.top
    anchors.left: prev.right
    text: Safe SQM:
    text-auto-resize: true
    font: verdana-11px-rounded
    margin-left: 147
    color: gray
    
  SpinBox
    id: sqmSafe
    anchors.top: prev.top
    anchors.left: prev.right
    size: 50 20
    margin-top: -5
    image-color: gray
    minimum: 1
    maximum: 10
    step: 1
    text-align: center
    
]], g_ui.getRootWidget())
comboInterface:hide();

comboInterface.closePanel.onClick = function()
  comboInterface:hide()
end

comboButton.settings.onClick = function()
    if not comboInterface:isVisible() then
        comboInterface:show()
        comboInterface:raise()
        comboInterface:focus()
    end
end

spellAddPanel = setupUI([[
UIWindow
  id: spellAddPanel
  size: 260 280
  border: 1 black
  anchors.centerIn: parent
  margin-top: -60

  Panel
    id: background
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    background-color: black
    opacity: 0.70

  Panel
    id: topPanel
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    size: 120 30
    text-align: center
    !text: tr('LNS SCRIPT-BOT')
    color: orange
    margin-left: 0
    margin-right: 0
    background-color: black
    $hover:
      image-color: gray
  
  Panel
    id: iconPanel
    anchors.top: parent.top
    anchors.left: parent.left
    size: 60 60
    margin-top: -19
    margin-left: -15

  FlatPanel
    id: panelMain
    anchors.top: prev.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: -7
    margin-right: 8
    margin-left: 8
    height: 215
    image-color: #363636

    Label
      id: magiaLabel
      anchors.top: parent.top
      anchors.left: parent.left
      anchors.right: parent.right
      text-align: left
      text: SPELL:
      margin-left: 10
      margin-right: 10
      margin-top: 5
      text-auto-resize: true
      font: verdana-9px-italic

    BotTextEdit
      id: magia
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 3
      image-color: gray

    Label
      id: distanceLabel
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 10
      text-align: left
      text: DISTANCE:
      text-auto-resize: true
      font: verdana-9px-italic

    HorizontalScrollBar
      id: distance
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 3
      minimum: 1
      maximum: 12
      step: 1

    Label
      id: manaLabel
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 10
      text-align: left
      text: MANA:
      text-auto-resize: true
      font: verdana-9px-italic

    HorizontalScrollBar
      id: mana
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 3
      minimum: 0
      maximum: 1000
      step: 10

    Label
      id: mobsLabel
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 10
      text-align: left
      text: MOBS:
      text-auto-resize: true
      font: verdana-9px-italic

    HorizontalScrollBar
      id: mobs
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 3
      minimum: 1
      maximum: 10
      step: 1

    Label
      id: cdLabel
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 10
      text-align: left
      text: COOLDOWN:
      text-auto-resize: true
      font: verdana-9px-italic

    HorizontalScrollBar
      id: cooldown
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-right: 10
      margin-top: 3
      minimum: 0
      maximum: 60000
      step: 1

    Button
      id: calculeCooldown
      anchors.top: prev.top
      anchors.left: prev.right
      text: !
      width: 10
      height: 13
      margin-left: 2
      font: verdana-11px-rounded

    CheckBox
      id: safe
      anchors.top: prev.bottom
      anchors.left: mobs.left
      anchors.right: mobs.right
      margin-top: 12
      text-align: left
      text: SPELL SAFE ?
      image-source: /images/ui/checkbox_round
      text-auto-resize: true
      font: verdana-9px-italic

  Button
    id: cancelarBt
    anchors.left: panelMain.left
    anchors.top: panelMain.bottom
    image-source: /images/ui/button_rounded
    size: 122 25
    margin-top: 2
    image-color: #363636
    text: Cancelar
    font: verdana-11px-rounded
    color: gray
    $hover:
      color: #FF4040

  Button
    id: adicionarBt
    anchors.right: panelMain.right
    anchors.top: panelMain.bottom
    image-source: /images/ui/button_rounded
    size: 122 25
    margin-top: 2
    image-color: #363636
    text: Adicionar
    font: verdana-11px-rounded
    color: gray
    $hover:
      color: #98FB98

]], g_ui.getRootWidget())
spellAddPanel:hide()

runeAddPanel = setupUI([[
UIWindow
  id: runeAddPanel
  size: 260 208
  border: 1 black
  anchors.centerIn: parent
  margin-top: -60

  Panel
    id: background
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    background-color: black
    opacity: 0.70

  Panel
    id: topPanel
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    size: 120 30
    text-align: center
    !text: tr('LNS SCRIPT-BOT')
    color: orange
    margin-left: 0
    margin-right: 0
    background-color: black
    $hover:
      image-color: gray
  
  Panel
    id: iconPanel
    anchors.top: parent.top
    anchors.left: parent.left
    size: 60 60
    margin-top: -19
    margin-left: -15

  FlatPanel
    id: panelMain
    anchors.top: prev.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: -7
    margin-right: 8
    margin-left: 8
    height: 145
    image-color: #363636

    Label
      id: runaLabel
      anchors.top: parent.top
      anchors.left: parent.left
      anchors.right: parent.right
      text-align: left
      text: ID RUNA:
      margin-left: 10
      margin-right: 10
      margin-top: 5
      text-auto-resize: true
      font: verdana-9px-italic

    BotTextEdit
      id: runa
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 3
      image-color: gray

    Label
      id: distanceLabel
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 10
      text-align: left
      text: DISTANCE:
      text-auto-resize: true
      font: verdana-9px-italic

    HorizontalScrollBar
      id: distance
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 3
      minimum: 1
      maximum: 12
      step: 1

    Label
      id: mobsLabel
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 10
      text-align: left
      text: MOBS:
      text-auto-resize: true
      font: verdana-9px-italic

    HorizontalScrollBar
      id: mobs
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 3
      minimum: 1
      maximum: 10
      step: 1

    Label
      id: cdLabel
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 10
      text-align: left
      text: COOLDOWN:
      text-auto-resize: true
      font: verdana-9px-italic
      visible: false

    HorizontalScrollBar
      id: cooldown
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-right: 10
      margin-top: 3
      minimum: 0
      maximum: 5000
      step: 1
      visible: false

    Button
      id: calculeCooldown
      anchors.top: prev.top
      anchors.left: prev.right
      text: !
      width: 10
      height: 13
      margin-left: 2
      font: verdana-11px-rounded
      visible: false

    CheckBox
      id: safe
      anchors.top: mobs.bottom
      anchors.left: mobs.left
      anchors.right: mobs.right
      margin-top: 12
      text-align: left
      text: RUNA SAFE ?
      image-source: /images/ui/checkbox_round
      text-auto-resize: true
      font: verdana-9px-italic

  Button
    id: cancelarBt
    anchors.left: panelMain.left
    anchors.top: panelMain.bottom
    image-source: /images/ui/button_rounded
    size: 122 25
    margin-top: 2
    image-color: #363636
    text: Cancelar
    font: verdana-11px-rounded
    color: gray
    $hover:
      color: #FF4040

  Button
    id: adicionarBt
    anchors.right: panelMain.right
    anchors.top: panelMain.bottom
    image-source: /images/ui/button_rounded
    size: 122 25
    margin-top: 2
    image-color: #363636
    text: Adicionar
    font: verdana-11px-rounded
    color: gray
    $hover:
      color: #98FB98

]], g_ui.getRootWidget())
runeAddPanel:hide()

local STORAGE_KEY = "combo_actions_global_v1"

local function deepCopy(t)
  if type(t) ~= "table" then return t end
  local r = {}
  for k, v in pairs(t) do r[k] = deepCopy(v) end
  return r
end

local function clamp(n, a, b)
  n = tonumber(n) or a
  if n < a then return a end
  if n > b then return b end
  return n
end

local function trim(s)
  s = tostring(s or "")
  return (s:gsub("^%s+", ""):gsub("%s+$", ""))
end

local function isEmpty(s) return trim(s) == "" end

local function W(root, id)
  if not root then return nil end
  if root.recursiveGetChildById then return root:recursiveGetChildById(id) end
  if root.getChildById then return root:getChildById(id) end
  return nil
end

local function clearChildren(w)
  if not w then return end
  local children = w:getChildren() or {}
  for i = #children, 1, -1 do
    local child = children[i]
    if child and not child:isDestroyed() then
      child:destroy()
    end
  end
end

local function msToSecText(ms)
  ms = tonumber(ms) or 0
  return string.format("%.1f", ms / 1000)
end

local function nowMs()
  if type(now) == "number" then return now end
  if g_clock and g_clock.millis then return g_clock.millis() end
  return (os.time() * 1000) + math.floor((os.clock() * 1000) % 1000)
end

local function setItemIcon(widget, itemId)
  if not widget then return end
  itemId = tonumber(itemId)
  if not itemId or itemId <= 0 then
    widget:setVisible(false)
    return
  end
  widget:setVisible(true)
  if widget.setItemId then
    widget:setItemId(itemId)
    return
  end
  if widget.setItem and g_things and g_things.getThingType then
    widget:setItem({ id = itemId, count = 1 })
  end
end

local function defaultCfg()
  return {
    main = {
      enabled = true,
      virarTarget = false,
      manterDist  = false,
      checkStairs = true,
      ignoreParty = false,
      stopOnPk    = true,
      sqmSafe     = 8,
      safeIdsAndares = {435, 1948, 386},
    },
    actions = {
      -- { type="spell", enabled=true, spell="exori gran", dist=3, mana=200, mobs=2, cd=1200, safe=true }
      -- { type="rune",  enabled=true, runeId=3155,        dist=7, mana=0,   mobs=1, cd=800,  safe=false }
    },
    draft = {
      spell = { cd = 0 },
      rune  = { cd = 0 },
    }
  }
end

local function mergeDefaults(dst, def)
  if type(dst) ~= "table" then dst = {} end
  for k,v in pairs(def) do
    if dst[k] == nil then
      dst[k] = deepCopy(v)
    elseif type(v) == "table" and type(dst[k]) == "table" then
      dst[k] = mergeDefaults(dst[k], v)
    end
  end
  return dst
end

storage[STORAGE_KEY] = mergeDefaults(storage[STORAGE_KEY], defaultCfg())
local cfg = storage[STORAGE_KEY]

if type(cfg.main.safeIdsAndares) ~= "table" then cfg.main.safeIdsAndares = {435,1948,386} end
if type(cfg.actions) ~= "table" then cfg.actions = {} end
cfg.draft = cfg.draft or { spell = { cd = 0 }, rune = { cd = 0 } }
cfg.draft.spell = cfg.draft.spell or { cd = 0 }
cfg.draft.rune  = cfg.draft.rune  or { cd = 0 }

if cfg.spells and type(cfg.spells) == "table" and #cfg.actions == 0 then
  for _, sp in ipairs(cfg.spells) do
    table.insert(cfg.actions, {
      type="spell",
      enabled = (sp.enabled ~= false),
      spell = tostring(sp.spell or ""),
      dist = tonumber(sp.dist or 1) or 1,
      mana = tonumber(sp.mana or 0) or 0,
      mobs = tonumber(sp.mobs or 0) or 0,
      cd   = tonumber(sp.cd or 0) or 0,
      safe = sp.safe and true or false
    })
  end
  cfg.spells = nil
end

local ui   = comboInterface
local spUI = spellAddPanel
local rnUI = runeAddPanel

-- main widgets
local spellList   = ui.spellList
local addSpellBtn = ui.adicionarSpell
local addRuneBtn  = ui.adicionarRuna
local upBtn       = ui.moveUp
local downBtn     = ui.moveDown

local offHealing  = ui.offHealing
local virarTarget = ui.virarTarget
local manterDist  = ui.manterDist
local checkStairs = ui.CheckStairs
local ignoreParty = ui.IgnoreParty
local stopOnPk    = ui.stopOnPk
local sqmSafe     = ui.sqmSafe
local idsSafePanel= ui.idsSafeAndares

-- spell panel widgets
local sp_spell    = W(spUI, "magia")
local sp_dist     = W(spUI, "distance")
local sp_mana     = W(spUI, "mana")
local sp_mobs     = W(spUI, "mobs")
local sp_cd       = W(spUI, "cooldown")
local sp_safe     = W(spUI, "safe")
local sp_cancel   = W(spUI, "cancelarBt")
local sp_add      = W(spUI, "adicionarBt")
local sp_dLbl     = W(spUI, "distanceLabel")
local sp_mLbl     = W(spUI, "manaLabel")
local sp_mbLbl    = W(spUI, "mobsLabel")
local sp_cdLbl    = W(spUI, "cdLabel")
local sp_calcBtn  = W(spUI, "calculeCooldown")

-- rune panel widgets
local rn_id       = W(rnUI, "runa")
local rn_dist     = W(rnUI, "distance")
local rn_mobs     = W(rnUI, "mobs")
local rn_cd       = W(rnUI, "cooldown")
local rn_safe     = W(rnUI, "safe")
local rn_cancel   = W(rnUI, "cancelarBt")
local rn_add      = W(rnUI, "adicionarBt")
local rn_dLbl     = W(rnUI, "distanceLabel")
local rn_mbLbl    = W(rnUI, "mobsLabel")
local rn_cdLbl    = W(rnUI, "cdLabel")
local rn_calcBtn  = W(rnUI, "calculeCooldown")

local idsSafeContainer = UI.Container(function(_, items)
  if type(items) ~= "table" then items = {} end
  cfg.main.safeIdsAndares = items
end, true)

idsSafeContainer:setParent(idsSafePanel)
idsSafeContainer:fill('parent')
idsSafeContainer:setOpacity(0.60)
idsSafeContainer:setItems(cfg.main.safeIdsAndares)

local rowTemplate = [[
UIWidget
  id: root
  height: 18
  focusable: true
  background-color: alpha
  opacity: 1.00

  $hover:
    background-color: #2F2F2F
    opacity: 0.75

  $focus:
    background-color: #404040
    opacity: 0.90

  CheckBox
    id: enabled
    anchors.left: parent.left
    anchors.verticalCenter: parent.verticalCenter
    width: 14
    height: 14
    margin-left: 3
    image-source: /images/ui/checkbox_round

  UIItem
    id: icon
    anchors.left: enabled.right
    anchors.verticalCenter: parent.verticalCenter
    margin-left: 2
    size: 20 20
    visible: false

  Label
    id: spellName
    anchors.left: enabled.right
    anchors.verticalCenter: parent.verticalCenter
    margin-top: 0
    margin-left: 6
    font: verdana-9px-bold
    color: white
    text: ""

  Label
    id: distText
    anchors.left: prev.right
    anchors.verticalCenter: parent.verticalCenter
    margin-left: 5
    font: verdana-9px
    text-auto-resize: true
    color: white
    text: "0Sqm"

  Label
    id: mobsText
    anchors.left: prev.right
    anchors.verticalCenter: parent.verticalCenter
    margin-left: 0
    font: verdana-9px
    text-auto-resize: true
    color: white
    text: "Mobs +0"

  Label
    id: safeText
    anchors.left: prev.right
    anchors.verticalCenter: parent.verticalCenter
    margin-left: 1
    margin-top: -1
    font: verdana-9px-bold
    text-auto-resize: true
    color: white
    text: "SAFE: N"

  Button
    id: remove
    anchors.right: parent.right
    anchors.verticalCenter: parent.verticalCenter
    width: 16
    height: 16
    margin-right: 2
    text: X
    color: #FF4040
    image-color: #363636
    image-source: /images/ui/button_rounded
]]

local function updateSpellPanelLabels()
  if sp_dLbl and sp_dist then sp_dLbl:setText("DISTANCE: " .. (sp_dist:getValue() or 0)) end
  if sp_mLbl and sp_mana then sp_mLbl:setText("MANA: " .. (sp_mana:getValue() or 0)) end
  if sp_mbLbl and sp_mobs then sp_mbLbl:setText("MOBS: " .. (sp_mobs:getValue() or 0)) end
  if sp_cdLbl then
    local v = (cfg.draft and cfg.draft.spell and cfg.draft.spell.cd) or (sp_cd and sp_cd:getValue()) or 0
    sp_cdLbl:setText("COOLDOWN: " .. (tonumber(v) or 0) .. " ms")
  end
end

local function updateRunePanelLabels()
  if rn_dLbl and rn_dist then rn_dLbl:setText("DISTANCE: " .. (rn_dist:getValue() or 0)) end
  if rn_mbLbl and rn_mobs then rn_mbLbl:setText("MOBS: " .. (rn_mobs:getValue() or 0)) end
  if rn_cdLbl then
    local v = (cfg.draft and cfg.draft.rune and cfg.draft.rune.cd) or (rn_cd and rn_cd:getValue()) or 0
    rn_cdLbl:setText("COOLDOWN: " .. (tonumber(v) or 0) .. " ms")
  end
end

local function resetSpellForm()
  if sp_spell then sp_spell:setText("") end
  if sp_dist then sp_dist:setValue(1) end
  if sp_mana then sp_mana:setValue(0) end
  if sp_mobs then sp_mobs:setValue(0) end
  if sp_cd then sp_cd:setValue(0) end
  if sp_safe then sp_safe:setChecked(false) end
  cfg.draft.spell.cd = 0
  updateSpellPanelLabels()
end

local function resetRuneForm()
  if rn_id then rn_id:setText("") end
  if rn_dist then rn_dist:setValue(1) end
  if rn_mobs then rn_mobs:setValue(0) end
  if rn_cd then rn_cd:setValue(0) end
  if rn_safe then rn_safe:setChecked(false) end
  cfg.draft.rune.cd = 0
  updateRunePanelLabels()
end

if sp_dist then sp_dist.onValueChange = function() updateSpellPanelLabels() end end
if sp_mana then sp_mana.onValueChange = function() updateSpellPanelLabels() end end
if sp_mobs then sp_mobs.onValueChange = function() updateSpellPanelLabels() end end

if sp_cd then
  sp_cd.onValueChange = function(widget, value)
    local v = tonumber(value)
    if not v and widget and widget.getValue then v = tonumber(widget:getValue()) end
    v = clamp(v or 0, 0, 60000)
    cfg.draft.spell.cd = v
    updateSpellPanelLabels()
  end
end

if rn_dist then rn_dist.onValueChange = function() updateRunePanelLabels() end end
if rn_mobs then rn_mobs.onValueChange = function() updateRunePanelLabels() end end

if rn_cd then
  rn_cd.onValueChange = function(widget, value)
    local v = tonumber(value)
    if not v and widget and widget.getValue then v = tonumber(widget:getValue()) end
    v = clamp(v or 0, 0, 60000)
    cfg.draft.rune.cd = v
    updateRunePanelLabels()
  end
end

local function getSelectedIndex()
  local focused = spellList and spellList:getFocusedChild() or nil
  if not focused then return nil end
  return spellList:getChildIndex(focused)
end

local editingIndex = nil -- index dentro de cfg.actions

local function refreshList()
  if not spellList then return end
  clearChildren(spellList)

  for i, entry in ipairs(cfg.actions) do
    if entry.enabled == nil then entry.enabled = true end
    if entry.safe == nil then entry.safe = false end
    if entry.type ~= "spell" and entry.type ~= "rune" then entry.type = "spell" end

    local row = setupUI(rowTemplate, spellList)
    row.entryIndex = i

    row.enabled:setChecked(entry.enabled and true or false)
    row.enabled.onClick = function()
      entry.enabled = not entry.enabled
      row.enabled:setChecked(entry.enabled)
    end

    row.remove.onClick = function()
      table.remove(cfg.actions, row.entryIndex)
      editingIndex = nil
      refreshList()
    end

    if entry.type == "rune" then
      row.spellName:setText("   ")
      row.spellName:setVisible(true)
      setItemIcon(row.icon, entry.runeId)
      row.icon:setVisible(true)
    else
      row.icon:setVisible(false)
      row.spellName:setVisible(true)
      row.spellName:setColor("orange")
      row.spellName:setText(tostring(entry.spell or ""))
    end

    local dist = tonumber(entry.dist or 0) or 0
    local mobs = tonumber(entry.mobs or 0) or 0
    row.distText:setText(string.format("[%d Sqm Range | ", dist))
    row.mobsText:setText(string.format("+%d Creature]", mobs))

    local safeChar  = entry.safe and "SAFE" or "UNSAFE"
    local safeColor = entry.safe and "#00FF00" or "#FF4040"
    if row.safeText.setColoredText then
      row.safeText:setColoredText({ "[", "white", safeChar, safeColor, "]", "white" })
    else
      row.safeText:setText("[SAFE: " .. safeChar .. "]")
      row.safeText:setColor(safeColor)
    end

    local tip = ""
    if entry.type == "spell" then
      tip = string.format(
        "Spell: %s\nDist: %d\nMobs: %d\nMP: %d\nCD: %ss\nSafe: %s",
        tostring(entry.spell or ""),
        dist,
        mobs,
        tonumber(entry.mana or 0) or 0,
        msToSecText(entry.cd),
        entry.safe and "SAFE" or "UNSAFE"
      )
    else
      tip = string.format(
        "Rune ID: %d\nDist: %d\nMobs: %d\nCD: %ss\nSafe: %s",
        tonumber(entry.runeId or 0) or 0,
        dist,
        mobs,
        msToSecText(entry.cd),
        entry.safe and "SAFE" or "UNSAFE"
      )
    end
    row:setTooltip(tip)

    row.onClick = function(widget)
      spellList:focusChild(widget)
    end

    row.onDoubleClick = function(widget)
      local idx = widget.entryIndex
      local e = cfg.actions[idx]
      if not e then return end
      editingIndex = idx

      if e.type == "rune" then
        if rn_id then rn_id:setText(tostring(e.runeId or "")) end
        if rn_dist then rn_dist:setValue(clamp(e.dist or 1, 0, 12)) end
        if rn_mobs then rn_mobs:setValue(clamp(e.mobs or 0, 0, 10)) end

        local cdv = clamp(tonumber(e.cd or 0) or 0, 0, 60000)
        cfg.draft.rune.cd = cdv
        if rn_cd then rn_cd:setValue(cdv) end
        if rn_cd and rn_cd.onValueChange then pcall(function() rn_cd.onValueChange(rn_cd, cdv) end) end

        if rn_safe then rn_safe:setChecked(e.safe and true or false) end
        updateRunePanelLabels()
        comboInterface:hide()
        rnUI:show(); rnUI:raise(); rnUI:focus()
      else
        if sp_spell then sp_spell:setText(tostring(e.spell or "")) end
        if sp_dist then sp_dist:setValue(clamp(e.dist or 1, 0, 12)) end
        if sp_mana then sp_mana:setValue(clamp(e.mana or 0, 0, 1000)) end
        if sp_mobs then sp_mobs:setValue(clamp(e.mobs or 0, 0, 10)) end

        local cdv = clamp(tonumber(e.cd or 0) or 0, 0, 60000)
        cfg.draft.spell.cd = cdv
        if sp_cd then sp_cd:setValue(cdv) end
        if sp_cd and sp_cd.onValueChange then pcall(function() sp_cd.onValueChange(sp_cd, cdv) end) end

        if sp_safe then sp_safe:setChecked(e.safe and true or false) end
        updateSpellPanelLabels()
        comboInterface:hide()
        spUI:show(); spUI:raise(); spUI:focus()
      end
    end
  end
end

upBtn.onClick = function()
  local idx = getSelectedIndex()
  if not idx or idx < 2 then return end
  cfg.actions[idx], cfg.actions[idx-1] = cfg.actions[idx-1], cfg.actions[idx]
  refreshList()
  local newFocus = spellList:getChildByIndex(idx-1)
  if newFocus then spellList:focusChild(newFocus) end
end

downBtn.onClick = function()
  local idx = getSelectedIndex()
  if not idx or idx >= #cfg.actions then return end
  cfg.actions[idx], cfg.actions[idx+1] = cfg.actions[idx+1], cfg.actions[idx]
  refreshList()
  local newFocus = spellList:getChildByIndex(idx+1)
  if newFocus then spellList:focusChild(newFocus) end
end

if offHealing then
  offHealing:setOn(cfg.main.enabled and true or false)
  offHealing.onClick = function(w) cfg.main.enabled = w:isOn() end
end
if virarTarget then
  virarTarget:setChecked(cfg.main.virarTarget and true or false)
  virarTarget.onCheckChange = function(w) cfg.main.virarTarget = w:isChecked() end
end
if manterDist then
  manterDist:setChecked(cfg.main.manterDist and true or false)
  manterDist.onCheckChange = function(w) cfg.main.manterDist = w:isChecked() end
end
if checkStairs then
  checkStairs:setChecked(cfg.main.checkStairs and true or false)
  checkStairs.onCheckChange = function(w) cfg.main.checkStairs = w:isChecked() end
end
if ignoreParty then
  ignoreParty:setChecked(cfg.main.ignoreParty and true or false)
  ignoreParty.onCheckChange = function(w) cfg.main.ignoreParty = w:isChecked() end
end
if stopOnPk then
  stopOnPk:setChecked(cfg.main.stopOnPk and true or false)
  stopOnPk.onCheckChange = function(w) cfg.main.stopOnPk = w:isChecked() end
end
if sqmSafe then
  sqmSafe:setValue(clamp(cfg.main.sqmSafe, 1, 10))
  sqmSafe.onValueChange = function(w, v)
    cfg.main.sqmSafe = clamp(v, 1, 10)
    w:setValue(cfg.main.sqmSafe)
  end
end

addSpellBtn.onClick = function()
  editingIndex = nil
  resetSpellForm()
  spUI:show(); spUI:raise(); spUI:focus()
  comboInterface:hide()
end

addRuneBtn.onClick = function()
  editingIndex = nil
  resetRuneForm()
  rnUI:show(); rnUI:raise(); rnUI:focus()
  comboInterface:hide()
end

sp_cancel.onClick = function() spUI:hide() comboInterface:show() end
rn_cancel.onClick = function() rnUI:hide() comboInterface:show() end

sp_add.onClick = function()
  local spell = trim(sp_spell and sp_spell:getText() or "")
  if isEmpty(spell) then return warn("[Combo] Preencha o campo SPELL.") end

  local entry = {
    type    = "spell",
    enabled = true,
    spell   = spell,
    dist    = clamp(sp_dist and sp_dist:getValue() or 1, 0, 12),
    mana    = clamp(sp_mana and sp_mana:getValue() or 0, 0, 1000),
    mobs    = clamp(sp_mobs and sp_mobs:getValue() or 0, 0, 10),
    cd      = clamp((cfg.draft and cfg.draft.spell and cfg.draft.spell.cd) or (sp_cd and sp_cd:getValue()) or 0, 0, 60000),
    safe    = (sp_safe and sp_safe:isChecked()) or false
  }

  if editingIndex and cfg.actions[editingIndex] then
    entry.enabled = cfg.actions[editingIndex].enabled ~= false
    cfg.actions[editingIndex] = entry
  else
    table.insert(cfg.actions, entry)
  end

  refreshList()
  editingIndex = nil
  resetSpellForm()
  spUI:hide()
  comboInterface:show()
end

rn_add.onClick = function()
  local runeId = tonumber(trim(rn_id and rn_id:getText() or ""))
  if not runeId or runeId <= 0 then return warn("[Combo] ID da runa invalido.") end

  local entry = {
    type    = "rune",
    enabled = true,
    runeId  = runeId,
    dist    = clamp(rn_dist and rn_dist:getValue() or 1, 0, 12),
    mana    = 0,
    mobs    = clamp(rn_mobs and rn_mobs:getValue() or 0, 0, 10),
    cd      = clamp((cfg.draft and cfg.draft.rune and cfg.draft.rune.cd) or (rn_cd and rn_cd:getValue()) or 0, 0, 60000),
    safe    = (rn_safe and rn_safe:isChecked()) or false
  }

  if editingIndex and cfg.actions[editingIndex] then
    entry.enabled = cfg.actions[editingIndex].enabled ~= false
    cfg.actions[editingIndex] = entry
  else
    table.insert(cfg.actions, entry)
  end

  refreshList()
  editingIndex = nil
  resetRuneForm()
  rnUI:hide()
  comboInterface:show()
end

spUI:hide()
rnUI:hide()
resetSpellForm()
resetRuneForm()
updateSpellPanelLabels()
updateRunePanelLabels()
refreshList()

local function showMessage(msg)
    if modules and modules.game_textmessage and modules.game_textmessage.displayGameMessage then
      modules.game_textmessage.displayGameMessage(msg)
    end
  end

cfg.main.disabledByFrag = cfg.main.disabledByFrag or {} -- lista de indices desligados
local skullDropAt = 0

local function iAmFrag()
  local p = g_game.getLocalPlayer()
  if not p then return false end
  local skull = p.getSkull and p:getSkull() or 0
  return skull >= 3
end

local function iAmDead()
  local p = g_game.getLocalPlayer()
  if not p then return false end
  if p.getHealthPercent then
    return (p:getHealthPercent() or 100) <= 0
  end
  return false
end

local function disableUnsafeActions()
  local did = false
  -- evita duplicar indices
  local mark = {}
  for _, idx in ipairs(cfg.main.disabledByFrag) do mark[idx] = true end

  for i, a in ipairs(cfg.actions or {}) do
    if a and a.enabled ~= false and a.safe == false then
      a.enabled = false
      if not mark[i] then
        table.insert(cfg.main.disabledByFrag, i)
        mark[i] = true
      end
      did = true
    end
  end

  if did and type(refreshList) == "function" then refreshList() end
  if did then showMessage("[LNS-SCRIPT] PK/FRAG Detectado - SPELLS UNSAFE DESLIGADAS!") end
end

local function restoreUnsafeActions()
  if type(cfg.main.disabledByFrag) ~= "table" or #cfg.main.disabledByFrag == 0 then return end

  for _, idx in ipairs(cfg.main.disabledByFrag) do
    local a = cfg.actions and cfg.actions[idx]
    if a then a.enabled = true end
  end

  cfg.main.disabledByFrag = {}
  skullDropAt = 0

  if type(refreshList) == "function" then refreshList() end
  showMessage("[LNS-SCRIPT] PK Expirado - SPELLS UNSAFE RELIGADAS.")
end

macro(200, function()
  if not storage[switchCombo].enabled then return end
  if not ui or not ui.stopOnPk or not ui.stopOnPk.isChecked then return end

  if not ui.stopOnPk:isChecked() then
    restoreUnsafeActions()
    return
  end

  local frag = iAmFrag()

  if frag and (#cfg.main.disabledByFrag == 0) then
    disableUnsafeActions()
    skullDropAt = 0
    return
  end

  -- se já desligou, espera ficar safe pra restaurar (ou morte)
  if #cfg.main.disabledByFrag > 0 then
    if iAmDead() then
      restoreUnsafeActions()
      return
    end

    if frag then
      skullDropAt = 0
    else
      if skullDropAt == 0 then skullDropAt = os.time() end
      -- pode restaurar imediatamente ao perder skull
      if os.time() >= skullDropAt then
        restoreUnsafeActions()
      end
    end
  end
end)

restoreUnsafeActions()

local cdSpell = { active=false, spell="", lastTime=0 }

local function stopSpellCalc()
  cdSpell.active = false
  cdSpell.spell = ""
  cdSpell.lastTime = 0
end

macro(100, function()
  if not cdSpell.active then return end
  if cdSpell.spell == "" then stopSpellCalc(); return end
  say(cdSpell.spell)
end)

onTalk(function(name, level, mode, text)
  if not cdSpell.active then return end
  local player = g_game.getLocalPlayer()
  if not player then return end
  if name ~= player:getName() then return end

  local msg = trim(text):lower()
  local expected = trim(cdSpell.spell):lower()
  if expected == "" or msg ~= expected then return end

  local t = nowMs()
  if cdSpell.lastTime > 0 then
    local cd = math.floor(t - cdSpell.lastTime)
    local v = clamp(cd, 0, 60000)

    if sp_cd and sp_cd.setValue then
      sp_cd:setValue(v)
      cfg.draft.spell.cd = v
      if sp_cd.onValueChange then pcall(function() sp_cd.onValueChange(sp_cd, v) end) end
    else
      cfg.draft.spell.cd = v
      updateSpellPanelLabels()
    end

    warn(string.format("[CD-SPELL] %d ms (%.1fs)", v, v/1000))
    stopSpellCalc()
  else
    cdSpell.lastTime = t
  end
end)

if sp_calcBtn then
  sp_calcBtn.onClick = function()
    local spell = trim(sp_spell and sp_spell:getText() or "")
    if spell == "" then return end
    cdSpell.active = true
    cdSpell.spell = spell
    cdSpell.lastTime = 0
  end
end

cfg.draft = cfg.draft or {}
cfg.draft.rune = cfg.draft.rune or { cd = 0 }

local runeCd = {
  active    = false,
  runeId    = 0,
  missileId = nil,
  lastTime  = 0
}

local function nowMs()
  if now then return now end
  return (os.time() * 1000) + math.floor((os.clock() * 1000) % 1000)
end

local function stopRuneCd()
  runeCd.active = false
  runeCd.runeId = 0
  runeCd.missileId = nil
  runeCd.lastTime = 0
end

local function applyRuneCd(ms)
  ms = math.floor(tonumber(ms) or 0)
  if ms < 0 then ms = 0 end
  if ms > 60000 then ms = 60000 end

  cfg.draft.rune.cd = ms

  local rn_cd = runeAddPanel and W(runeAddPanel, "cooldown")
  if rn_cd and rn_cd.setValue then
    rn_cd:setValue(ms)
  end

  if type(updateRunePanelLabels) == "function" then
    updateRunePanelLabels()
  end

  warn(string.format("[CD-RUNE] %d ms (%.1fs)", ms, ms / 1000))
  stopRuneCd()
end

local function tryUseRune(runeId)
  local target = g_game.getAttackingCreature()
  if not target then target = g_game.getLocalPlayer() end
  if not target then return false end

  if type(useWith) ~= "function" then
    warn("[CD-RUNE] useWith() nao existe no seu client.")
    return false
  end

  local ok = pcall(function()
    useWith(runeId, target)
  end)

  return ok
end

local runeAuto = {
  active = false,
  runeId = 0,
  stage = 0,       -- 1=forcar 1o missile, 2=forcar 2o missile
  nextAt = 0,
  startedAt = 0
}

local function startAutoRune2x(runeId)
  runeAuto.active = true
  runeAuto.runeId = tonumber(runeId) or 0
  runeAuto.stage = 1
  runeAuto.nextAt = 0
  runeAuto.startedAt = nowMs()
end

macro(60, function()
  if not runeAuto.active then return end
  if runeAuto.runeId <= 0 then runeAuto.active = false; return end

  if not runeCd.active then runeAuto.active = false; return end

  local t = nowMs()

  if t - runeAuto.startedAt > 20000 then
    warn("[CD-RUNE] Timeout: nao consegui medir (sem 2 missiles).")
    runeAuto.active = false
    return
  end

  if runeAuto.nextAt ~= 0 and t < runeAuto.nextAt then return end

  runeAuto.nextAt = t + 250

  if runeAuto.stage == 1 then
    tryUseRune(runeAuto.runeId)
    return
  end

  if runeAuto.stage == 2 then
    tryUseRune(runeAuto.runeId)
    return
  end
end)

local function handleRuneMissile(missile)
  if not runeCd.active or not missile then return end

  local player = g_game.getLocalPlayer()
  if not player then return end

  local src = missile:getSource()
  if not src then return end

  local tile = g_map.getTile(src)
  if not tile then return end

  local creatures = tile:getCreatures() or {}
  if #creatures == 0 then return end

  local caster = creatures[1]
  if caster:getName() ~= player:getName() then return end

  local mid = missile:getId()
  if not mid then return end

  local t = nowMs()

  if not runeCd.missileId then
    runeCd.missileId = mid
    runeCd.lastTime = t

    if runeAuto.active then
      runeAuto.stage = 2
      runeAuto.nextAt = 0
    end
    return
  end

  if mid ~= runeCd.missileId then return end

  if runeCd.lastTime > 0 then
    applyRuneCd(t - runeCd.lastTime)
    -- applyRuneCd -> stopRuneCd() -> runner para sozinho
  end
end

if type(onMissile) == "function" then
  pcall(function()
    onMissile(handleRuneMissile)
  end)
end

if type(onMissle) == "function" then
  pcall(function()
    onMissle(handleRuneMissile)
  end)
end

if g_map and connect then
  pcall(function()
    connect(g_map, {
      onMissile = function(_, missile)
        handleRuneMissile(missile)
      end
    })
  end)
end

do
  local btn = runeAddPanel and W(runeAddPanel, "calculeCooldown")
  if btn then
    btn.onClick = function()
      local rn_id = runeAddPanel and W(runeAddPanel, "runa")
      local runeId = tonumber(trim(rn_id and rn_id:getText() or ""))

      if not runeId or runeId <= 0 then
        return warn("[CD-RUNE] ID da runa inválido.")
      end

      stopRuneCd()
      runeCd.active = true
      runeCd.runeId = runeId

      -- [INSERIDO] força 2 usos (via tentativas + missile)
      startAutoRune2x(runeId)

      warn("[CD-RUNE] Aguardando missile...")
    end
  end
end

do
  local rn_cd = runeAddPanel and W(runeAddPanel, "cooldown")
  if rn_cd and rn_cd.setValue then
    rn_cd:setValue(tonumber(cfg.draft.rune.cd) or 0)
    if type(updateRunePanelLabels) == "function" then
      updateRunePanelLabels()
    end
  end
end

ANDAR_NAO_SAFE = false

local function buildIdLookup(ids)
  local t = {}
  if type(ids) ~= "table" then return t end
  for _, v in pairs(ids) do
    local id = nil
    if type(v) == "table" then
      id = (v.getId and v:getId()) or v.id
    else
      id = v
    end
    id = tonumber(id)
    if id then t[id] = true end
  end
  return t
end

local function checkStairsNearby(dist, idLookup)
  local player = g_game.getLocalPlayer()
  if not player then return false end
  local p = player:getPosition()
  if not p then return false end

  for x = -dist, dist do
    for y = -dist, dist do
      local tile = g_map.getTile({ x = p.x + x, y = p.y + y, z = p.z })
      if tile then
        for _, item in ipairs(tile:getItems() or {}) do
          if idLookup[item:getId()] then
            return true
          end
        end
      end
    end
  end
  return false
end

macro(200, function()
  if not ui or not ui.CheckStairs then ANDAR_NAO_SAFE = false return end
  if not ui.CheckStairs:isChecked() then ANDAR_NAO_SAFE = false return end

  local dist = clamp((cfg and cfg.main and cfg.main.sqmSafe) or 8, 1, 10)
  local ids = (cfg and cfg.main and cfg.main.safeIdsAndares) or {}
  local lookup = buildIdLookup(ids)

  ANDAR_NAO_SAFE = checkStairsNearby(dist, lookup)
end)

macro(300, function()
  local player = g_game.getLocalPlayer()
  if not player then return end
  if ANDAR_NAO_SAFE then
    player:setText("UNSAFE")
  else
    player:setText("")
  end
end)

PLAYERSINSCREEN = false

macro(200, function()
  if not ui or not ui.IgnoreParty or not ui.IgnoreParty.isChecked then
    PLAYERSINSCREEN = false
    return
  end

  local player = g_game.getLocalPlayer()
  if not player then return end

  if not ui.IgnoreParty:isChecked() then
    PLAYERSINSCREEN = false
    return
  end

  local range = 8
  if cfg and cfg.main then
    range = clamp(cfg.main.sqmSafe, 1, 10)
  elseif ui.sqmSafe and ui.sqmSafe.getValue then
    range = clamp(ui.sqmSafe:getValue(), 1, 10)
  end

  local foundEnemy = false
  local spectators = getSpectators() or {}

  for _, spec in ipairs(spectators) do
    if spec and spec:isPlayer() and not spec:isLocalPlayer() then
      local dist = getDistanceBetween(player:getPosition(), spec:getPosition())
      if dist <= range then
        if not (spec:isPartyMember() or (spec.getShield and spec:getShield() > 0)) then
          if not (spec.getEmblem and spec:getEmblem() == 1) then
            foundEnemy = true
            break
          end
        end
      end
    end
  end

  PLAYERSINSCREEN = foundEnemy

end)

local lastMove = 0
local moveDelay = 25
local lastDir = nil
local stableUntil = 0

local function chebyshevDist(a, b)
  return math.max(math.abs(a.x - b.x), math.abs(a.y - b.y))
end

local function stepPos(p, dir)
  local n = {x = p.x, y = p.y, z = p.z}
  if dir == 0 then n.y = n.y - 1
  elseif dir == 1 then n.x = n.x + 1
  elseif dir == 2 then n.y = n.y + 1
  elseif dir == 3 then n.x = n.x - 1
  elseif dir == 4 then n.x = n.x + 1; n.y = n.y - 1
  elseif dir == 5 then n.x = n.x + 1; n.y = n.y + 1
  elseif dir == 6 then n.x = n.x - 1; n.y = n.y + 1
  elseif dir == 7 then n.x = n.x - 1; n.y = n.y - 1
  end
  return n
end

local function isWalkableFree(pos)
  local tile = g_map.getTile(pos)
  if not tile or not tile:isWalkable() then return false end
  local cr = tile:getCreatures() or {}
  return #cr == 0
end

macro(200, function()
  if not ui or not ui.manterDist or not ui.manterDist.isChecked then return end
  if not (storage[switchCombo].enabled and ui.manterDist:isChecked()) then return end

  local target = g_game.getAttackingCreature()
  if not target then return end

  local player = g_game.getLocalPlayer()
  if not player then return end

  local pPos = player:getPosition()
  local tPos = target:getPosition()
  if not pPos or not tPos or pPos.z ~= tPos.z then return end

  local nowt = nowMs()
  if nowt - lastMove < moveDelay then return end

  local dist = chebyshevDist(pPos, tPos)
  local desiredDist = 4

  if dist <= 1 then
    local bestDir, bestScore = -1, -999999
    for dir = 0, 7 do
      local np = stepPos(pPos, dir)
      if isWalkableFree(np) then
        local newDist = chebyshevDist(np, tPos)
        local score = newDist * 10
        if dir <= 3 then score = score + 2 else score = score - 1 end
        if lastDir and ((dir + 2) % 4 == lastDir) then score = score - 8 end
        if lastDir and dir == lastDir then score = score + 3 end
        if newDist >= 2 then score = score + 5 end
        if score > bestScore then
          bestScore = score
          bestDir = dir
        end
      end
    end

    if bestDir ~= -1 then
      if player:isAutoWalking() then player:stopAutoWalk() end
      g_game.walk(bestDir)
      lastDir = bestDir
      lastMove = nowt
      stableUntil = nowt + 400
    end
    return
  end

  if dist > desiredDist then
    if nowt < stableUntil then return end
    if not player:isAutoWalking() then
      g_game.autoWalk(tPos, { precision = desiredDist - 1, ignoreNonPathable = true })
      lastMove = nowt
      stableUntil = nowt + 350
    end
    lastDir = nil
    return
  end

  if nowt > stableUntil then lastDir = nil end
end)

local lastTurn = 0
local turnDelay = 20

local function getDir4(fromPos, toPos)
  local dx = toPos.x - fromPos.x
  local dy = toPos.y - fromPos.y
  if dx == 0 and dy == 0 then return nil end
  if math.abs(dx) > math.abs(dy) then
    return (dx > 0) and 1 or 3
  else
    return (dy > 0) and 2 or 0
  end
end

macro(30, function()
  if not (storage[switchCombo].enabled and comboInterface.virarTarget:isChecked()) then return end

  local player = g_game.getLocalPlayer()
  if not player then return end

  local target = g_game.getAttackingCreature()
  if not target then return end

  local pPos = player:getPosition()
  local tPos = target:getPosition()
  if not pPos or not tPos or pPos.z ~= tPos.z then return end

  local nowt = nowMs()
  if nowt - lastTurn < turnDelay then return end

  local dir = getDir4(pPos, tPos)
  if not dir then return end

  local curDir = player.getDirection and player:getDirection() or nil
  if curDir ~= nil and curDir == dir then return end

  if turn then
    turn(dir)
  elseif g_game.turn then
    g_game.turn(dir)
  end

  lastTurn = nowt
end)

local runeToMissile = {
    [3155] = 32,  -- SD
    [3175] = 20,
    [3191] = 4,
    [3161] = 22,
    [3202] = 25
}

onTalk(function(name, level, mode, text, channelId, pos)
    if name ~= g_game.getLocalPlayer():getName() then return end
    text = text:lower()
    
    -- Varre sua lista de ações para ver se o que você falou é uma magia do combo
    if cfg and cfg.actions then
        for _, action in ipairs(cfg.actions) do
            if action.enabled and action.type == "spell" and action.spell:lower() == text then
                -- Aplica o cooldown REAL configurado na action + tempo atual
                action.nextCast = now + (action.cd or 1000)
            end
        end
    end
end)

onMissle(function(missle)
    local player = g_game.getLocalPlayer()
    if not player then return end

    local src = missle:getSource()
    
    -- Verifica se o míssil saiu do mesmo SQM que o player está
    -- (Método mais leve e rápido que getCreatures)
    local pPos = player:getPosition()
    if src.z ~= pPos.z or src.x ~= pPos.x or src.y ~= pPos.y then return end

    local missleId = missle:getId()

    -- Varre a lista para achar qual runa tem esse efeito de tiro
    if cfg and cfg.actions then
        for _, action in ipairs(cfg.actions) do
            if action.enabled and action.type == "rune" then
                local rId = tonumber(action.runeId)
                -- Se o ID do míssil bater com o ID mapeado da runa
                if rId and runeToMissile[rId] == missleId then
                    -- Aplica o cooldown REAL configurado na action
                    userRune = now + (action.cd or 1000)
                end
            end
        end
    end
end)

local SPAM_DELAY = 50 -- Tempo de espera "provisório" até o servidor responder

macro(100, function()
    if not storage[switchCombo].enabled then return end
    if not cfg.main.enabled then return end 

    local player = g_game.getLocalPlayer()
    local target = g_game.getAttackingCreature()
    
    if not player or not target then return end
    if player:isNpc() then return end

    if cfg.main.stopOnPk and target:isPlayer() then return end

    local pPos = player:getPosition()
    local tPos = target:getPosition()
    
    if not pPos or not tPos or pPos.z ~= tPos.z then return end

    local dist = math.max(math.abs(pPos.x - tPos.x), math.abs(pPos.y - tPos.y))

    for i, action in ipairs(cfg.actions) do
        if action.enabled then
            
            -- 1. Checagem de Cooldown (Baseada no onTalk/onMissle)
            -- Se 'nextCast' não existir, assume que está pronto (0)
            local isReady = now >= (action.nextCast or 0)

            -- 2. Checagens de Distância e Mana
            local distOk = dist <= (action.dist or 8)
            
            local manaOk = true
            if action.type == "spell" then
                local needMana = tonumber(action.mana) or 0
                if player:getMana() < needMana then manaOk = false end
            end

            local mobsOk = true
            if (action.mobs or 0) > 0 then
                local count = 0
                local specs = g_map.getSpectators(pPos, false)
                for _, s in ipairs(specs) do
                    if s:isMonster() then
                        local sPos = s:getPosition()
                        local sd = math.max(math.abs(pPos.x - sPos.x), math.abs(pPos.y - sPos.y))
                        if sd <= 7 then count = count + 1 end
                    end
                end
                if count < action.mobs then mobsOk = false end
            end

            -- 4. LÓGICA SAFE (Safe Checkbox)
            -- Checkbox MARCADO = SAFE (Pode usar sempre)
            -- Checkbox DESMARCADO = UNSAFE (Verifica perigos)
            local safeOk = true
            
            if not action.safe then -- Se for magia PERIGOSA
                -- Verifica variáveis globais (que vem do seu outro script)
                if cfg.main.checkStairs and ANDAR_NAO_SAFE then safeOk = false end
                if cfg.main.checkPlayers and PLAYERSINSCREEN then safeOk = false end
            end

            if isReady and distOk and manaOk and mobsOk and safeOk then
                
                if action.type == "spell" then
                    say(action.spell)
                    delay(2000)
                    action.nextCast = now + SPAM_DELAY 
                    return 

                elseif action.type == "rune" then
                    local rid = tonumber(action.runeId)
                    if rid and rid > 0 then
                      if (not userRune or userRune <= now) then
                        useWith(rid, target) 
                      end
                      return
                    end
                end
            end
        end
    end
end)

local switchHealing = "healingButton"

if not storage[switchHealing] then
    storage[switchHealing] = { enabled = false }
end

local healingButton = setupUI([[
Panel
  height: 20
  margin-top: -3
  
  BotSwitch
    id: title
    anchors.top: parent.top
    anchors.left: parent.left
    text-align: center
    width: 110
    text: Healing
    font: verdana-9px
    color: white
    image-source: /images/ui/button_rounded
    $on:
      font: verdana-9px
      color: green

  Button
    id: settings
    anchors.top: prev.top
    anchors.left: prev.right
    anchors.right: parent.right
    margin-left: 0
    height: 17
    text: Config
    font: verdana-9px
    image-source: /images/ui/button_rounded
]])
healingButton:setId(switchHealing)
healingButton.title:setOn(storage[switchHealing].enabled)

healingButton.title.onClick = function(widget)
    local newState = not widget:isOn()
    widget:setOn(newState)
    storage[switchHealing].enabled = newState
end

local mainPanel = setupUI([[  
SpellRow < Panel
  height: 25
  margin-top: 3

  ComboBox
    id: spell
    anchors.left: parent.left
    anchors.verticalCenter: parent.verticalCenter
    margin-left: 0
    width: 120
    font: verdana-11px-rounded
    text-align: center
    image-color: #828282

  Label
    id: lblHp
    anchors.left: spell.right
    anchors.verticalCenter: parent.verticalCenter
    margin-left: 8
    text-auto-resize: true
    text: HP% <=
    font: verdana-11px-rounded
    width: 30

  SpinBox
    id: hp
    anchors.left: lblHp.right
    anchors.verticalCenter: parent.verticalCenter
    width: 60
    margin-left: 3
    minimum: 0
    maximum: 100
    step: 1
    text-align: center
    focusable: true
    editable: true
    image-color: #828282

  Label
    id: lblMana
    anchors.left: hp.right
    anchors.verticalCenter: parent.verticalCenter
    margin-left: 10
    text: MP% <= 
    text-auto-resize: true  
    font: verdana-11px-rounded
    width: 35

  SpinBox
    id: mana
    anchors.left: lblMana.right
    anchors.verticalCenter: parent.verticalCenter
    width: 60
    margin-left: 5
    minimum: 0
    maximum: 1000
    step: 1
    text-align: center
    editable: true
    image-color: #828282

BotHealingPot < Panel
  height: 32
  margin-top: 3

  BotItem
    id: potionHp
    anchors.left: parent.left
    anchors.top: parent.top
    margin-top: 0
    border: 1 #8B0000
    opacity: 0.80

  Button
    id: resourceText
    anchors.top: potionHp.top
    anchors.left: potionHp.right
    anchors.right: parent.right
    margin-left: 5
    margin-right: 5
    text-align: center
    font: verdana-11px-rounded
    image-source: /images/ui/button_rounded
    image-color: 	#EE0000
    height: 18

  HorizontalScrollBar
    id: scrollMin
    anchors.left: resourceText.left
    anchors.top: resourceText.bottom
    anchors.right: resourceText.right
    margin-top: 3
    margin-right: 2
    minimum: 0
    maximum: 100
    step: 1

BotHealingPotMP < Panel
  height: 32
  margin-top: 3

  BotItem
    id: potionHp
    anchors.left: parent.left
    anchors.top: parent.top
    margin-top: 0
    border: 1 #00B2EE
    opacity: 0.80

  Button
    id: resourceText
    anchors.top: potionHp.top
    anchors.left: potionHp.right
    anchors.right: parent.right
    margin-left: 5
    margin-right: 5
    font: verdana-11px-rounded
    text-align: center
    image-source: /images/ui/button_rounded
    image-color: 	#00B2EE
    height: 18

  HorizontalScrollBar
    id: scrollMax
    anchors.left: resourceText.left
    anchors.right: resourceText.right
    anchors.top: resourceText.bottom
    margin-top: 3
    margin-left: 2
    minimum: 0
    maximum: 100
    step: 1

UIWindow
  id: mainPanel
  size: 400 390
  border: 1 black
  anchors.centerIn: parent
  margin-top: -60

  Panel
    id: background
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    background-color: black
    opacity: 0.70

  Panel
    id: topPanel
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    size: 120 30
    text-align: center
    !text: tr('LNS SCRIPT-BOT')
    color: orange
    margin-left: 0
    margin-right: 0
    background-color: black
    $hover:
      image-color: gray
  
  Panel
    id: iconPanel
    anchors.top: topPanel.top
    anchors.left: parent.left
    size: 60 60
    margin-top: -28
    margin-left: -15

  UIButton
    id: closePanel
    anchors.top: topPanel.top
    anchors.right: parent.right
    size: 18 18
    margin-top: 6
    margin-right: 10
    background-color: orange
    text: X
    color: white
    opacity: 1.00
    $hover:
      color: black
      opacity: 0.80

  FlatPanel
    id: panelMain
    anchors.top: prev.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: 18
    margin-right: 8
    margin-left: 8
    height: 120
    image-color: #363636
    layout: verticalBox

  Label
    id: labelHealing
    anchors.top: prev.top
    anchors.left: panelMain.left
    text: HEALING SPELLS:
    text-auto-resize: true
    font: verdana-9px-italic
    margin-top: -5
    margin-left: 10

  BotSwitch
    id: offHealing
    anchors.top: prev.top
    anchors.left: prev.right
    image-souce: /images/ui/button_rounded
    image-color: #363636
    margin-left: 5
    margin-top: -3
    width: 60
    $!on
      opacity: 0.70
      image-color: #363636
      text: OFFLINE
      color: red
    $on:
      opacity: 1.00
      color: #7CFC00
      text: ONLINE
      image-color: #363636

  SpellRow
    id: rowSpell1
    anchors.top: labelHealing.bottom
    anchors.left: panelMain.left
    anchors.right: panelMain.right
    margin-left: 10
    margin-top: 10

  SpellRow
    id: rowSpell2
    anchors.top: rowSpell1.bottom
    anchors.left: rowSpell1.left
    anchors.right: rowSpell1.right
    margin-top: 10

  SpellRow
    id: rowSpell3
    anchors.top: rowSpell2.bottom
    anchors.left: rowSpell2.left
    anchors.right: rowSpell2.right
    margin-top: 10

  FlatPanel
    id: panelPotion
    anchors.top: prev.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: 25
    margin-right: 8
    margin-left: 8
    height: 145
    image-color: #363636
    layout: verticalBox

  Label
    id: labelPotion
    anchors.top: prev.top
    anchors.left: panelPotion.left
    text: POTIONS HEALTH/MANA:
    text-auto-resize: true
    font: verdana-9px-italic
    margin-top: -5
    margin-left: 10

  BotSwitch
    id: offPotions
    anchors.top: prev.top
    anchors.left: prev.right
    image-souce: /images/ui/button_rounded
    image-color: #363636
    margin-left: 5
    margin-top: -3
    width: 60
    $!on
      opacity: 0.70
      image-color: #363636
      text: OFFLINE
      color: red
    $on:
      opacity: 1.00
      color: #7CFC00
      text: ONLINE
      image-color: #363636

  BotHealingPot
    id: rowPotionhp1
    anchors.top: labelPotion.bottom
    anchors.left: labelPotion.left
    width: 180
    margin-top: 10

  BotHealingPot
    id: rowPotionhp2
    anchors.top: rowPotionhp1.bottom
    anchors.left: rowPotionhp1.left
    width: 180
    margin-top: 10

  BotHealingPot
    id: rowPotionhp3
    anchors.top: rowPotionhp2.bottom
    anchors.left: rowPotionhp2.left
    width: 180
    margin-top: 10

  BotHealingPotMP
    id: rowPotionMp1
    anchors.top: labelPotion.bottom
    anchors.left: rowPotionhp1.right
    width: 180
    margin-top: 10
    margin-left: 10

  BotHealingPotMP
    id: rowPotionMp2
    anchors.top: rowPotionMp1.bottom
    anchors.left: rowPotionMp1.left
    width: 180
    margin-top: 10

  BotHealingPotMP
    id: rowPotionMp3
    anchors.top: rowPotionMp2.bottom
    anchors.left: rowPotionMp2.left
    width: 180
    margin-top: 10

  FlatPanel
    id: panelFood
    anchors.top: prev.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: 25
    margin-right: 8
    margin-left: 8
    height: 55
    image-color: #363636
    layout: verticalBox

  Label
    id: labelFood
    anchors.top: prev.top
    anchors.left: panelFood.left
    text: AUTO FOOD:
    text-auto-resize: true
    font: verdana-9px-italic
    margin-top: -5
    margin-left: 10

  BotSwitch
    id: offFood
    anchors.top: prev.top
    anchors.left: prev.right
    image-souce: /images/ui/button_rounded
    image-color: #363636
    margin-left: 5
    margin-top: -3
    width: 60
    $!on
      opacity: 0.70
      image-color: #363636
      text: OFFLINE
      color: red
    $on:
      opacity: 1.00
      color: #7CFC00
      text: ONLINE
      image-color: #363636

  Panel
    id: foodContainerPanel
    anchors.top: labelFood.bottom
    anchors.left: panelFood.left
    anchors.right: panelFood.right
    size: 270 35
    margin-top: 5
    margin-left: 5
    margin-right: 5

]], g_ui.getRootWidget())
mainPanel:hide()

mainPanel.closePanel.onClick = function()
  mainPanel:hide()
end

if type(storage.foodItems) ~= "table" then
  storage.foodItems = { 3607, 3585, 3592, 3600, 3601 }
end
local destPanel = mainPanel.foodContainerPanel
local foodContainer = UI.Container(function(widget, items)
  storage.foodItems = items
end, true)

foodContainer:setParent(destPanel)
foodContainer:fill('parent')
foodContainer:setOpacity(0.70)
foodContainer:setImageColor("#363636")
foodContainer:setItems(storage.foodItems)

macro(500, function()
  -- segurança básica
  if not player then return end

  -- condição 1: auto food ONLINE
  if not storage.lnsHealingPanel
     or not storage.lnsHealingPanel.toggles
     or storage.lnsHealingPanel.toggles.offFood ~= true then
    return
  end

  -- condição 2: healingButton enabled
  if not storage[switchHealing]
     or storage[switchHealing].enabled ~= true then
    return
  end

  -- sem comida configurada
  if type(storage.foodItems) ~= "table" or not storage.foodItems[1] then
    return
  end

  -- ainda com buff de food ativo
  if player:getRegenerationTime() > 400 then return end

  -- procura comida nos containers
  for _, container in pairs(g_game.getContainers()) do
    local items = container:getItems()
    if items then
      for _, item in ipairs(items) do
        for _, foodItem in ipairs(storage.foodItems) do
          if item:getId() == foodItem.id then
            g_game.use(item)
            return
          end
        end
      end
    end
  end
end)


healingButton.settings.onClick = function()
    if not mainPanel:isVisible() then
        mainPanel:show()
        mainPanel:raise()
        mainPanel:focus()
    end
end

local panelName = "lnsHealingPanel"

-- Spells padronizadas (como você pediu)
local SPELL_OPTIONS = {
  "", -- vazio = desativado
  "Exura",
  "Exura Gran",
  "Exura Vita",
  "Exura San",
  "Exura Gran San",
  "Exura Ico",
  "Exura Med Ico",
  "Exura Gran Ico"
}

-- "Amarração" da mana por spell (mana mínima necessária pra castar)
-- (valores padrão mais comuns; você pode ajustar se seu servidor for diferente)
local SPELL_MANA_COST = {
  ["Exura"] = 20,
  ["Exura Gran"] = 70,
  ["Exura Vita"] = 160,
  ["Exura San"] = 160,
  ["Exura Gran San"] = 210,
  ["Exura Ico"] = 40,
  ["Exura Med Ico"] = 90,
  ["Exura Gran Ico"] = 200
}

-- Defaults (se não existir no storage)
local DEFAULT_ROWS = {
  { spell = "Exura",          hp = 90, mana = 20  },
  { spell = "Exura Gran",     hp = 70, mana = 70  },
  { spell = "Exura Vita",     hp = 50, mana = 160 }
}

local function ensureStorage()
  if not storage[panelName] or type(storage[panelName]) ~= "table" then
    storage[panelName] = {}
  end
  if type(storage[panelName].rows) ~= "table" then
    storage[panelName].rows = {}
  end

  for i = 1, 3 do
    if type(storage[panelName].rows[i]) ~= "table" then
      storage[panelName].rows[i] = {
        spell = DEFAULT_ROWS[i].spell,
        hp = DEFAULT_ROWS[i].hp,
        mana = DEFAULT_ROWS[i].mana
      }
    end
    if storage[panelName].rows[i].hp == nil then storage[panelName].rows[i].hp = DEFAULT_ROWS[i].hp end
    if storage[panelName].rows[i].mana == nil then storage[panelName].rows[i].mana = DEFAULT_ROWS[i].mana end
    if storage[panelName].rows[i].spell == nil then storage[panelName].rows[i].spell = DEFAULT_ROWS[i].spell end
  end
end

local function comboSelectByText(combo, text)
  if not combo then return end
  text = tostring(text or ""):lower()

  local idx = 1
  for i, s in ipairs(SPELL_OPTIONS) do
    if tostring(s):lower() == text then
      idx = i
      break
    end
  end

  -- tenta por índice
  if combo.setCurrentIndex then
    combo:setCurrentIndex(idx)
    return
  end

  -- fallback (algumas versões usam setCurrentOption)
  if combo.setCurrentOption then
    combo:setCurrentOption(SPELL_OPTIONS[idx])
    return
  end
end


local function fillComboOptions(combo)
  combo:clearOptions()
  for _, s in ipairs(SPELL_OPTIONS) do
    combo:addOption(s)
  end
end

local function bindSpellRow(rowWidget, rowIndex)
  if not rowWidget then return end

  local combo = rowWidget.spell
  local hpBox = rowWidget.hp
  local manaBox = rowWidget.mana

  -- popula combobox
  fillComboOptions(combo)

  -- aplica valores do storage na UI
  local rowStore = storage[panelName].rows[rowIndex]
  comboSelectByText(combo, rowStore.spell)
  hpBox:setValue(tonumber(rowStore.hp) or 0)
  manaBox:setValue(tonumber(rowStore.mana) or 0)

  -- eventos: salvar quando mexer
  combo.onOptionChange = function(widget)
    local chosen = widget:getCurrentOption().text or ""
    rowStore.spell = chosen

    local cost = SPELL_MANA_COST[chosen]
    if cost then
      local cur = tonumber(manaBox:getValue()) or 0
      if cur < cost or cur > cost then
        manaBox:setValue(cost)
        rowStore.mana = cost
      end
    end
  end

  hpBox.onValueChange = function(widget, value)
    rowStore.hp = tonumber(value) or 0
  end

  manaBox.onValueChange = function(widget, value)
    rowStore.mana = tonumber(value) or 0
  end
end

-- init
ensureStorage()

-- bind 3 rows
bindSpellRow(mainPanel.rowSpell1, 1)
bindSpellRow(mainPanel.rowSpell2, 2)
bindSpellRow(mainPanel.rowSpell3, 3)

-- =========================================
-- POTIONS STORAGE (HP/MP) - OTCv8 SAFE (BASEADO NA SUA BASE)
-- =========================================

local panelName = "lnsHealingPanel" -- usa o mesmo se já existir

-- cria storage default
if not storage[panelName] then storage[panelName] = {} end
if not storage[panelName].potions then storage[panelName].potions = {} end
if not storage[panelName].potions.hp then storage[panelName].potions.hp = {} end
if not storage[panelName].potions.mp then storage[panelName].potions.mp = {} end

for i = 1, 3 do
  if not storage[panelName].potions.hp[i] then storage[panelName].potions.hp[i] = { id = 0, min = 50 } end
  if not storage[panelName].potions.mp[i] then storage[panelName].potions.mp[i] = { id = 0, max = 70 } end

  storage[panelName].potions.hp[i].id  = tonumber(storage[panelName].potions.hp[i].id) or 0
  storage[panelName].potions.hp[i].min = tonumber(storage[panelName].potions.hp[i].min) or 50

  storage[panelName].potions.mp[i].id  = tonumber(storage[panelName].potions.mp[i].id) or 0
  storage[panelName].potions.mp[i].max = tonumber(storage[panelName].potions.mp[i].max) or 70
end

local function updatePotionTextSingle(widget, value, isMana)
  value = tonumber(value) or 0
  local labelType = isMana and "MP% <=" or "HP% <="
  if widget and widget.resourceText then
    widget.resourceText:setText(labelType .. " " .. value .. "%")
  end
end

local function setupPotionEntrySingle(widget, data, isMana)
  if not widget then return end
  if not data then data = { id = 0, min = 0, max = 0 } end

  local botItem = widget.potionHp
  local slider  = isMana and widget.scrollMax or widget.scrollMin

  -- aplica item e slider do storage
  if botItem and botItem.setItemId then
    botItem:setItemId(tonumber(data.id) or 0)
  end

  if slider and slider.setValue then
    local v = isMana and (tonumber(data.max) or 0) or (tonumber(data.min) or 0)
    slider:setValue(v)
    updatePotionTextSingle(widget, v, isMana)
  end

  -- callback: quando trocar o item
  if botItem and botItem.onItemChange then
    botItem.onItemChange = function(w)
      local item = w:getItem()
      if item then
        data.id = item:getId()
      else
        data.id = 0
      end
    end
  end

  -- callback: quando mexer no slider
  if slider then
  slider.onValueChange = function(s, v)
    v = tonumber(v) or 0
    if isMana then
      data.max = v
    else
      data.min = v
    end
    updatePotionTextSingle(widget, v, isMana)
    end
  end
end

-- binds HP (rowPotionhp1..3)
setupPotionEntrySingle(mainPanel.rowPotionhp1, storage[panelName].potions.hp[1], false)
setupPotionEntrySingle(mainPanel.rowPotionhp2, storage[panelName].potions.hp[2], false)
setupPotionEntrySingle(mainPanel.rowPotionhp3, storage[panelName].potions.hp[3], false)

-- binds MP (rowPotionMp1..3)
setupPotionEntrySingle(mainPanel.rowPotionMp1, storage[panelName].potions.mp[1], true)
setupPotionEntrySingle(mainPanel.rowPotionMp2, storage[panelName].potions.mp[2], true)
setupPotionEntrySingle(mainPanel.rowPotionMp3, storage[panelName].potions.mp[3], true)

if not storage[panelName] then storage[panelName] = {} end
if not storage[panelName].toggles then storage[panelName].toggles = {} end

local function bindToggleSwitch(switchWidget, key, defaultValue)
  if not switchWidget then return end

  if storage[panelName].toggles[key] == nil then
    storage[panelName].toggles[key] = (defaultValue == true)
  end

  -- aplica estado salvo
  switchWidget:setOn(storage[panelName].toggles[key] == true)

  -- salva ao clicar
  switchWidget.onClick = function(widget)
    local newState = not widget:isOn()
    widget:setOn(newState)
    storage[panelName].toggles[key] = newState
  end
end

bindToggleSwitch(mainPanel.offHealing, "offHealing", true)
bindToggleSwitch(mainPanel.offPotions, "offPotions", true)
bindToggleSwitch(mainPanel.offFood,    "offFood",    true)

-- =========================================
-- MACRO: Healing Spells (prioriza mais forte, fallback por mana)
-- Requisitos:
--  - storage.lnsHealingPanel.toggles.offHealing == true
--  - storage[switchHealing].enabled == true
-- =========================================

macro(100, function()
  if not player then return end

  -- Condição 1: switch do painel (ONLINE/OFFLINE)
  if not storage.lnsHealingPanel
     or not storage.lnsHealingPanel.toggles
     or storage.lnsHealingPanel.toggles.offHealing ~= true then
    return
  end

  -- Condição 2: healingButton enabled
  if not storage[switchHealing]
     or storage[switchHealing].enabled ~= true then
    return
  end

  local cfg = storage.lnsHealingPanel
  if not cfg.rows or type(cfg.rows) ~= "table" then return end

  local hp = hppercent()
  local mp = mana()

  -- monta lista de spells "aplicáveis" (hp <= threshold e spell != "")
  local candidates = {}

  for i = 1, 3 do
    local r = cfg.rows[i]
    if r and type(r) == "table" then
      local spell = tostring(r.spell or "")
      local hpTh = tonumber(r.hp) or 0
      local mpNeed = tonumber(r.mana) or 0

      if spell ~= "" and hp <= hpTh then
        -- custo real da spell (preferencial); fallback pro valor do row
        local realCost = SPELL_MANA_COST[spell] or mpNeed
        table.insert(candidates, {
          spell = spell,
          hpTh = hpTh,
          cost = tonumber(realCost) or 0
        })
      end
    end
  end

  if #candidates == 0 then return end

  -- ordena para priorizar a mais forte:
  -- quanto MENOR o hpTh, mais urgente/forte (ex: 50 é mais forte que 90)
  table.sort(candidates, function(a, b)
    return a.hpTh < b.hpTh
  end)

  -- tenta a melhor; se não tiver mana, faz fallback pras próximas
  for _, c in ipairs(candidates) do
    if mp >= (c.cost or 0) then
      say(c.spell)
      return
    end
  end
end)

-- =========================================
-- MACRO: Potions HP/MP (SEM precisar backpack aberta)
-- Usa useWith(itemId, player) em vez de g_game.use(item)
-- Condições:
--  1) storage.lnsHealingPanel.toggles.offPotions == true
--  2) storage[switchHealing].enabled == true
-- =========================================

macro(150, function()
  -- Condição 1: switch do painel (ONLINE/OFFLINE) das potions
  if not storage.lnsHealingPanel
     or not storage.lnsHealingPanel.toggles
     or storage.lnsHealingPanel.toggles.offPotions ~= true then
    return
  end

  -- Condição 2: healingButton enabled
  if not storage[switchHealing]
     or storage[switchHealing].enabled ~= true then
    return
  end

  local cfg = storage.lnsHealingPanel
  if not cfg.potions then return end

  local hp = hppercent()
  local mp = manapercent()

  local me = g_game.getLocalPlayer()
  if not me then return end

  -- =========================
  -- HP potions (min): usa se HP <= min
  -- Prioriza menor min (mais urgente)
  -- =========================
  if cfg.potions.hp and type(cfg.potions.hp) == "table" then
    local candidatesHP = {}
    for i = 1, 3 do
      local p = cfg.potions.hp[i]
      if p and type(p) == "table" then
        local id = tonumber(p.id) or 0
        local min = tonumber(p.min) or 0
        if id > 0 and hp <= min then
          table.insert(candidatesHP, { id = id, th = min })
        end
      end
    end

    if #candidatesHP > 0 then
      table.sort(candidatesHP, function(a, b) return a.th < b.th end)
      for _, c in ipairs(candidatesHP) do
        -- useWith não precisa de backpack aberta
        useWith(c.id, me)
        return
      end
    end
  end

  -- =========================
  -- MP potions (max): usa se MP <= max
  -- Prioriza menor max (mais urgente)
  -- =========================
  if cfg.potions.mp and type(cfg.potions.mp) == "table" then
    local candidatesMP = {}
    for i = 1, 3 do
      local p = cfg.potions.mp[i]
      if p and type(p) == "table" then
        local id = tonumber(p.id) or 0
        local max = tonumber(p.max) or 0
        if id > 0 and mp <= max then
          table.insert(candidatesMP, { id = id, th = max })
        end
      end
    end

    if #candidatesMP > 0 then
      table.sort(candidatesMP, function(a, b) return a.th < b.th end)
      for _, c in ipairs(candidatesMP) do
        useWith(c.id, me)
        return
      end
    end
  end
end)
