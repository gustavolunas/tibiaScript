local switchCombo = "comboButton"

if not storage[switchCombo] then
    storage[switchCombo] = { enabled = false }
end

local comboButton = setupUI([[
Panel
  height: 20

  BotSwitch
    id: title
    anchors.top: parent.top
    anchors.left: parent.left
    text-align: center
    width: 110
    text: AttackBot
    font: verdana-9px
    color: white
    image-source: /images/ui/button_rounded
    $on:
      font: verdana-9px
      color: green

  Button
    id: settings
    anchors.top: prev.top
    anchors.left: prev.right
    anchors.right: parent.right
    margin-left: 0
    height: 17
    text: Config
    font: verdana-9px
    image-source: /images/ui/button_rounded
]])
comboButton:setId(switchCombo)
comboButton.title:setOn(storage[switchCombo].enabled)

comboButton.title.onClick = function(widget)
    local newState = not widget:isOn()
    widget:setOn(newState)
    storage[switchCombo].enabled = newState
end

comboInterface = setupUI([[
UIWindow
  id: mainPanel
  size: 400 360
  border: 1 black
  anchors.centerIn: parent
  margin-top: -60

  Panel
    id: background
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    background-color: black
    opacity: 0.70

  Panel
    id: topPanel
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    size: 120 30
    text-align: center
    !text: tr('LNS SCRIPT-BOT')
    color: orange
    margin-left: 0
    margin-right: 0
    background-color: black
    $hover:
      image-color: gray
  
  Panel
    id: iconPanel
    anchors.top: parent.top
    anchors.left: parent.left
    size: 60 60
    margin-top: -19
    margin-left: -15

  UIButton
    id: closePanel
    anchors.top: topPanel.top
    anchors.right: parent.right
    size: 18 18
    margin-top: 6
    margin-right: 10
    background-color: orange
    text: X
    color: white
    opacity: 1.00
    $hover:
      color: black
      opacity: 0.80

  FlatPanel
    id: panelMain
    anchors.top: prev.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: 18
    margin-right: 8
    margin-left: 8
    height: 160
    image-color: #363636
    layout: verticalBox

  Label
    id: labelHealing
    anchors.top: prev.top
    anchors.left: panelMain.left
    text: CONFIGURATION SPELLS:
    text-auto-resize: true
    font: verdana-9px-italic
    margin-top: -5
    margin-left: 10

  BotSwitch
    id: offHealing
    anchors.top: prev.top
    anchors.left: prev.right
    image-souce: /images/ui/button_rounded
    image-color: #363636
    margin-left: 5
    margin-top: -3
    width: 60
    $!on
      opacity: 0.70
      image-color: #363636
      text: OFFLINE
      color: red
    $on:
      opacity: 1.00
      color: #7CFC00
      text: ONLINE
      image-color: #363636
      
  TextList
    opacity: 1.00
    id: spellList
    anchors.left: panelMain.left
    anchors.right: panelMain.right
    anchors.top: labelHealing.bottom
    padding: 1
    height: 120 
    margin-top: 5
    margin-left: 5
    margin-right: 17
    vertical-scrollbar: spellListScrollBar
    image-color: #363636

  VerticalScrollBar
    id: spellListScrollBar
    anchors.top: spellList.top
    anchors.bottom: spellList.bottom
    anchors.left: spellList.right
    step: 10
    pixels-scroll: true
    visible: true
    image-color: #363636
    opacity: 0.90

  Button
    id: adicionarSpell
    anchors.left: spellList.left
    anchors.top: spellList.bottom
    image-source: /images/ui/button_rounded
    size: 80 25
    margin-top: 2
    image-color: #363636
    text: Add Spell
    font: verdana-11px-rounded
    color: gray

  Button
    id: adicionarRuna
    anchors.left: adicionarSpell.right
    anchors.top: spellList.bottom
    image-source: /images/ui/button_rounded
    size: 80 25
    margin-top: 2
    image-color: #363636
    text: Add Rune
    font: verdana-11px-rounded
    color: gray

  Button
    id: moveUp
    anchors.right: spellListScrollBar.right
    anchors.top: spellList.bottom
    image-source: /images/ui/button_rounded
    size: 25 25
    margin-top: 2
    image-color: #363636
    text: /\
    font: verdana-11px-rounded
    color: gray

  Button
    id: moveDown
    anchors.right: moveUp.left
    anchors.top: spellList.bottom
    image-source: /images/ui/button_rounded
    size: 25 25
    margin-top: 2
    image-color: #363636
    text: \/
    font: verdana-11px-rounded
    color: gray

  FlatPanel
    id: panelTools
    anchors.top: panelMain.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: 8
    margin-right: 8
    margin-left: 8
    height: 60
    image-color: #363636
    layout: verticalBox

  Label
    id: labelTools
    anchors.top: prev.top
    anchors.left: panelMain.left
    text: CONFIG ATTACKER:
    text-auto-resize: true
    font: verdana-9px-italic
    margin-top: -5
    margin-left: 10


  CheckBox
    id: virarTarget
    anchors.top: labelTools.bottom
    anchors.left: labelTools.left
    text: Virar Target
    text-auto-resize: true
    font: verdana-11px-rounded
    color: gray
    image-source: /images/ui/checkbox_round
    margin-top: 10

  CheckBox
    id: manterDist
    anchors.top: prev.bottom
    anchors.left: prev.left
    text: Manter Distancia
    text-auto-resize: true
    font: verdana-11px-rounded
    image-source: /images/ui/checkbox_round
    color: gray
    margin-top: 10

  FlatPanel
    id: panelSafe
    anchors.top: panelTools.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: 8
    margin-right: 8
    margin-left: 8
    height: 80
    image-color: #363636
    layout: verticalBox

  Label
    id: labelSafe
    anchors.top: prev.top
    anchors.left: panelMain.left
    text: SAFE ZONE:
    text-auto-resize: true
    font: verdana-9px-italic
    margin-top: -5
    margin-left: 10
      
  CheckBox
    id: CheckStairs
    anchors.top: labelSafe.bottom
    anchors.left: labelSafe.left
    text: Checar Stairs
    text-auto-resize: true
    font: verdana-11px-rounded
    image-source: /images/ui/checkbox_round
    color: gray
    margin-top: 10

  Panel
    id: idsSafeAndares
    anchors.top: prev.top
    anchors.left: CheckStairs.right
    margin-top: -10
    margin-left: 13
    size: 250 35

  CheckBox
    id: IgnoreParty
    anchors.top: CheckStairs.bottom
    anchors.left: CheckStairs.left
    text: Checar Players
    text-auto-resize: true
    font: verdana-11px-rounded
    image-source: /images/ui/checkbox_round
    color: gray
    margin-top: 10

  CheckBox
    id: stopOnPk
    anchors.top: prev.bottom
    anchors.left: prev.left
    text: OFF PK/Frags
    text-auto-resize: true
    font: verdana-11px-rounded
    image-source: /images/ui/checkbox_round
    color: gray
    margin-top: 10

  Label
    id: labelSqm
    anchors.top: prev.top
    anchors.left: prev.right
    text: Safe SQM:
    text-auto-resize: true
    font: verdana-11px-rounded
    margin-left: 147
    color: gray
    
  SpinBox
    id: sqmSafe
    anchors.top: prev.top
    anchors.left: prev.right
    size: 50 20
    margin-top: -5
    image-color: gray
    minimum: 1
    maximum: 10
    step: 1
    text-align: center
    
]], g_ui.getRootWidget())
comboInterface:hide();

comboInterface.closePanel.onClick = function()
  comboInterface:hide()
end

comboButton.settings.onClick = function()
    if not comboInterface:isVisible() then
        comboInterface:show()
        comboInterface:raise()
        comboInterface:focus()
    end
end

spellAddPanel = setupUI([[
UIWindow
  id: spellAddPanel
  size: 260 280
  border: 1 black
  anchors.centerIn: parent
  margin-top: -60

  Panel
    id: background
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    background-color: black
    opacity: 0.70

  Panel
    id: topPanel
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    size: 120 30
    text-align: center
    !text: tr('LNS SCRIPT-BOT')
    color: orange
    margin-left: 0
    margin-right: 0
    background-color: black
    $hover:
      image-color: gray
  
  Panel
    id: iconPanel
    anchors.top: parent.top
    anchors.left: parent.left
    size: 60 60
    margin-top: -19
    margin-left: -15

  FlatPanel
    id: panelMain
    anchors.top: prev.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: -7
    margin-right: 8
    margin-left: 8
    height: 215
    image-color: #363636

    Label
      id: magiaLabel
      anchors.top: parent.top
      anchors.left: parent.left
      anchors.right: parent.right
      text-align: left
      text: SPELL:
      margin-left: 10
      margin-right: 10
      margin-top: 5
      text-auto-resize: true
      font: verdana-9px-italic

    BotTextEdit
      id: magia
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 3
      image-color: gray

    Label
      id: distanceLabel
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 10
      text-align: left
      text: DISTANCE:
      text-auto-resize: true
      font: verdana-9px-italic

    HorizontalScrollBar
      id: distance
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 3
      minimum: 1
      maximum: 12
      step: 1

    Label
      id: manaLabel
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 10
      text-align: left
      text: MANA:
      text-auto-resize: true
      font: verdana-9px-italic

    HorizontalScrollBar
      id: mana
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 3
      minimum: 0
      maximum: 1000
      step: 10

    Label
      id: mobsLabel
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 10
      text-align: left
      text: MOBS:
      text-auto-resize: true
      font: verdana-9px-italic

    HorizontalScrollBar
      id: mobs
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 3
      minimum: 1
      maximum: 10
      step: 1

    Label
      id: cdLabel
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 10
      text-align: left
      text: COOLDOWN:
      text-auto-resize: true
      font: verdana-9px-italic

    HorizontalScrollBar
      id: cooldown
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-right: 10
      margin-top: 3
      minimum: 0
      maximum: 60000
      step: 1

    Button
      id: calculeCooldown
      anchors.top: prev.top
      anchors.left: prev.right
      text: !
      width: 10
      height: 13
      margin-left: 2
      font: verdana-11px-rounded

    CheckBox
      id: safe
      anchors.top: prev.bottom
      anchors.left: mobs.left
      anchors.right: mobs.right
      margin-top: 12
      text-align: left
      text: SPELL SAFE ?
      image-source: /images/ui/checkbox_round
      text-auto-resize: true
      font: verdana-9px-italic

  Button
    id: cancelarBt
    anchors.left: panelMain.left
    anchors.top: panelMain.bottom
    image-source: /images/ui/button_rounded
    size: 122 25
    margin-top: 2
    image-color: #363636
    text: Cancelar
    font: verdana-11px-rounded
    color: gray
    $hover:
      color: #FF4040

  Button
    id: adicionarBt
    anchors.right: panelMain.right
    anchors.top: panelMain.bottom
    image-source: /images/ui/button_rounded
    size: 122 25
    margin-top: 2
    image-color: #363636
    text: Adicionar
    font: verdana-11px-rounded
    color: gray
    $hover:
      color: #98FB98

]], g_ui.getRootWidget())
spellAddPanel:hide()

runeAddPanel = setupUI([[
UIWindow
  id: runeAddPanel
  size: 260 208
  border: 1 black
  anchors.centerIn: parent
  margin-top: -60

  Panel
    id: background
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    background-color: black
    opacity: 0.70

  Panel
    id: topPanel
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    size: 120 30
    text-align: center
    !text: tr('LNS SCRIPT-BOT')
    color: orange
    margin-left: 0
    margin-right: 0
    background-color: black
    $hover:
      image-color: gray
  
  Panel
    id: iconPanel
    anchors.top: parent.top
    anchors.left: parent.left
    size: 60 60
    margin-top: -19
    margin-left: -15

  FlatPanel
    id: panelMain
    anchors.top: prev.bottom
    anchors.right: parent.right
    anchors.left: parent.left
    margin-top: -7
    margin-right: 8
    margin-left: 8
    height: 145
    image-color: #363636

    Label
      id: runaLabel
      anchors.top: parent.top
      anchors.left: parent.left
      anchors.right: parent.right
      text-align: left
      text: ID RUNA:
      margin-left: 10
      margin-right: 10
      margin-top: 5
      text-auto-resize: true
      font: verdana-9px-italic

    BotTextEdit
      id: runa
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 3
      image-color: gray

    Label
      id: distanceLabel
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 10
      text-align: left
      text: DISTANCE:
      text-auto-resize: true
      font: verdana-9px-italic

    HorizontalScrollBar
      id: distance
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 3
      minimum: 1
      maximum: 12
      step: 1

    Label
      id: mobsLabel
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 10
      text-align: left
      text: MOBS:
      text-auto-resize: true
      font: verdana-9px-italic

    HorizontalScrollBar
      id: mobs
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 3
      minimum: 1
      maximum: 10
      step: 1

    Label
      id: cdLabel
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-top: 10
      text-align: left
      text: COOLDOWN:
      text-auto-resize: true
      font: verdana-9px-italic
      visible: false

    HorizontalScrollBar
      id: cooldown
      anchors.top: prev.bottom
      anchors.left: prev.left
      anchors.right: prev.right
      margin-right: 10
      margin-top: 3
      minimum: 0
      maximum: 5000
      step: 1
      visible: false

    Button
      id: calculeCooldown
      anchors.top: prev.top
      anchors.left: prev.right
      text: !
      width: 10
      height: 13
      margin-left: 2
      font: verdana-11px-rounded
      visible: false

    CheckBox
      id: safe
      anchors.top: mobs.bottom
      anchors.left: mobs.left
      anchors.right: mobs.right
      margin-top: 12
      text-align: left
      text: RUNA SAFE ?
      image-source: /images/ui/checkbox_round
      text-auto-resize: true
      font: verdana-9px-italic

  Button
    id: cancelarBt
    anchors.left: panelMain.left
    anchors.top: panelMain.bottom
    image-source: /images/ui/button_rounded
    size: 122 25
    margin-top: 2
    image-color: #363636
    text: Cancelar
    font: verdana-11px-rounded
    color: gray
    $hover:
      color: #FF4040

  Button
    id: adicionarBt
    anchors.right: panelMain.right
    anchors.top: panelMain.bottom
    image-source: /images/ui/button_rounded
    size: 122 25
    margin-top: 2
    image-color: #363636
    text: Adicionar
    font: verdana-11px-rounded
    color: gray
    $hover:
      color: #98FB98

]], g_ui.getRootWidget())
runeAddPanel:hide()

local STORAGE_KEY = "combo_actions_global_v1"

local function deepCopy(t)
  if type(t) ~= "table" then return t end
  local r = {}
  for k, v in pairs(t) do r[k] = deepCopy(v) end
  return r
end

local function clamp(n, a, b)
  n = tonumber(n) or a
  if n < a then return a end
  if n > b then return b end
  return n
end

local function trim(s)
  s = tostring(s or "")
  return (s:gsub("^%s+", ""):gsub("%s+$", ""))
end

local function isEmpty(s) return trim(s) == "" end

local function W(root, id)
  if not root then return nil end
  if root.recursiveGetChildById then return root:recursiveGetChildById(id) end
  if root.getChildById then return root:getChildById(id) end
  return nil
end

local function clearChildren(w)
  if not w then return end
  local children = w:getChildren() or {}
  for i = #children, 1, -1 do
    local child = children[i]
    if child and not child:isDestroyed() then
      child:destroy()
    end
  end
end

local function msToSecText(ms)
  ms = tonumber(ms) or 0
  return string.format("%.1f", ms / 1000)
end

local function nowMs()
  if type(now) == "number" then return now end
  if g_clock and g_clock.millis then return g_clock.millis() end
  return (os.time() * 1000) + math.floor((os.clock() * 1000) % 1000)
end

local function setItemIcon(widget, itemId)
  if not widget then return end
  itemId = tonumber(itemId)
  if not itemId or itemId <= 0 then
    widget:setVisible(false)
    return
  end
  widget:setVisible(true)
  if widget.setItemId then
    widget:setItemId(itemId)
    return
  end
  if widget.setItem and g_things and g_things.getThingType then
    widget:setItem({ id = itemId, count = 1 })
  end
end

local function defaultCfg()
  return {
    main = {
      enabled = true,
      virarTarget = false,
      manterDist  = false,
      checkStairs = true,
      ignoreParty = false,
      stopOnPk    = true,
      sqmSafe     = 8,
      safeIdsAndares = {435, 1948, 386},
    },
    actions = {
      -- { type="spell", enabled=true, spell="exori gran", dist=3, mana=200, mobs=2, cd=1200, safe=true }
      -- { type="rune",  enabled=true, runeId=3155,        dist=7, mana=0,   mobs=1, cd=800,  safe=false }
    },
    draft = {
      spell = { cd = 0 },
      rune  = { cd = 0 },
    }
  }
end

local function mergeDefaults(dst, def)
  if type(dst) ~= "table" then dst = {} end
  for k,v in pairs(def) do
    if dst[k] == nil then
      dst[k] = deepCopy(v)
    elseif type(v) == "table" and type(dst[k]) == "table" then
      dst[k] = mergeDefaults(dst[k], v)
    end
  end
  return dst
end

storage[STORAGE_KEY] = mergeDefaults(storage[STORAGE_KEY], defaultCfg())
local cfg = storage[STORAGE_KEY]

if type(cfg.main.safeIdsAndares) ~= "table" then cfg.main.safeIdsAndares = {435,1948,386} end
if type(cfg.actions) ~= "table" then cfg.actions = {} end
cfg.draft = cfg.draft or { spell = { cd = 0 }, rune = { cd = 0 } }
cfg.draft.spell = cfg.draft.spell or { cd = 0 }
cfg.draft.rune  = cfg.draft.rune  or { cd = 0 }

if cfg.spells and type(cfg.spells) == "table" and #cfg.actions == 0 then
  for _, sp in ipairs(cfg.spells) do
    table.insert(cfg.actions, {
      type="spell",
      enabled = (sp.enabled ~= false),
      spell = tostring(sp.spell or ""),
      dist = tonumber(sp.dist or 1) or 1,
      mana = tonumber(sp.mana or 0) or 0,
      mobs = tonumber(sp.mobs or 0) or 0,
      cd   = tonumber(sp.cd or 0) or 0,
      safe = sp.safe and true or false
    })
  end
  cfg.spells = nil
end

local ui   = comboInterface
local spUI = spellAddPanel
local rnUI = runeAddPanel

-- main widgets
local spellList   = ui.spellList
local addSpellBtn = ui.adicionarSpell
local addRuneBtn  = ui.adicionarRuna
local upBtn       = ui.moveUp
local downBtn     = ui.moveDown

local offHealing  = ui.offHealing
local virarTarget = ui.virarTarget
local manterDist  = ui.manterDist
local checkStairs = ui.CheckStairs
local ignoreParty = ui.IgnoreParty
local stopOnPk    = ui.stopOnPk
local sqmSafe     = ui.sqmSafe
local idsSafePanel= ui.idsSafeAndares

-- spell panel widgets
local sp_spell    = W(spUI, "magia")
local sp_dist     = W(spUI, "distance")
local sp_mana     = W(spUI, "mana")
local sp_mobs     = W(spUI, "mobs")
local sp_cd       = W(spUI, "cooldown")
local sp_safe     = W(spUI, "safe")
local sp_cancel   = W(spUI, "cancelarBt")
local sp_add      = W(spUI, "adicionarBt")
local sp_dLbl     = W(spUI, "distanceLabel")
local sp_mLbl     = W(spUI, "manaLabel")
local sp_mbLbl    = W(spUI, "mobsLabel")
local sp_cdLbl    = W(spUI, "cdLabel")
local sp_calcBtn  = W(spUI, "calculeCooldown")

-- rune panel widgets
local rn_id       = W(rnUI, "runa")
local rn_dist     = W(rnUI, "distance")
local rn_mobs     = W(rnUI, "mobs")
local rn_cd       = W(rnUI, "cooldown")
local rn_safe     = W(rnUI, "safe")
local rn_cancel   = W(rnUI, "cancelarBt")
local rn_add      = W(rnUI, "adicionarBt")
local rn_dLbl     = W(rnUI, "distanceLabel")
local rn_mbLbl    = W(rnUI, "mobsLabel")
local rn_cdLbl    = W(rnUI, "cdLabel")
local rn_calcBtn  = W(rnUI, "calculeCooldown")

local idsSafeContainer = UI.Container(function(_, items)
  if type(items) ~= "table" then items = {} end
  cfg.main.safeIdsAndares = items
end, true)

idsSafeContainer:setParent(idsSafePanel)
idsSafeContainer:fill('parent')
idsSafeContainer:setOpacity(0.60)
idsSafeContainer:setItems(cfg.main.safeIdsAndares)

local rowTemplate = [[
UIWidget
  id: root
  height: 18
  focusable: true
  background-color: alpha
  opacity: 1.00

  $hover:
    background-color: #2F2F2F
    opacity: 0.75

  $focus:
    background-color: #404040
    opacity: 0.90

  CheckBox
    id: enabled
    anchors.left: parent.left
    anchors.verticalCenter: parent.verticalCenter
    width: 14
    height: 14
    margin-left: 3
    image-source: /images/ui/checkbox_round

  UIItem
    id: icon
    anchors.left: enabled.right
    anchors.verticalCenter: parent.verticalCenter
    margin-left: 2
    size: 20 20
    visible: false

  Label
    id: spellName
    anchors.left: enabled.right
    anchors.verticalCenter: parent.verticalCenter
    margin-top: 0
    margin-left: 6
    font: verdana-9px-bold
    color: white
    text: ""

  Label
    id: distText
    anchors.left: prev.right
    anchors.verticalCenter: parent.verticalCenter
    margin-left: 5
    font: verdana-9px
    text-auto-resize: true
    color: white
    text: "0Sqm"

  Label
    id: mobsText
    anchors.left: prev.right
    anchors.verticalCenter: parent.verticalCenter
    margin-left: 0
    font: verdana-9px
    text-auto-resize: true
    color: white
    text: "Mobs +0"

  Label
    id: safeText
    anchors.left: prev.right
    anchors.verticalCenter: parent.verticalCenter
    margin-left: 1
    margin-top: -1
    font: verdana-9px-bold
    text-auto-resize: true
    color: white
    text: "SAFE: N"

  Button
    id: remove
    anchors.right: parent.right
    anchors.verticalCenter: parent.verticalCenter
    width: 16
    height: 16
    margin-right: 2
    text: X
    color: #FF4040
    image-color: #363636
    image-source: /images/ui/button_rounded
]]

local function updateSpellPanelLabels()
  if sp_dLbl and sp_dist then sp_dLbl:setText("DISTANCE: " .. (sp_dist:getValue() or 0)) end
  if sp_mLbl and sp_mana then sp_mLbl:setText("MANA: " .. (sp_mana:getValue() or 0)) end
  if sp_mbLbl and sp_mobs then sp_mbLbl:setText("MOBS: " .. (sp_mobs:getValue() or 0)) end
  if sp_cdLbl then
    local v = (cfg.draft and cfg.draft.spell and cfg.draft.spell.cd) or (sp_cd and sp_cd:getValue()) or 0
    sp_cdLbl:setText("COOLDOWN: " .. (tonumber(v) or 0) .. " ms")
  end
end

local function updateRunePanelLabels()
  if rn_dLbl and rn_dist then rn_dLbl:setText("DISTANCE: " .. (rn_dist:getValue() or 0)) end
  if rn_mbLbl and rn_mobs then rn_mbLbl:setText("MOBS: " .. (rn_mobs:getValue() or 0)) end
  if rn_cdLbl then
    local v = (cfg.draft and cfg.draft.rune and cfg.draft.rune.cd) or (rn_cd and rn_cd:getValue()) or 0
    rn_cdLbl:setText("COOLDOWN: " .. (tonumber(v) or 0) .. " ms")
  end
end

local function resetSpellForm()
  if sp_spell then sp_spell:setText("") end
  if sp_dist then sp_dist:setValue(1) end
  if sp_mana then sp_mana:setValue(0) end
  if sp_mobs then sp_mobs:setValue(0) end
  if sp_cd then sp_cd:setValue(0) end
  if sp_safe then sp_safe:setChecked(false) end
  cfg.draft.spell.cd = 0
  updateSpellPanelLabels()
end

local function resetRuneForm()
  if rn_id then rn_id:setText("") end
  if rn_dist then rn_dist:setValue(1) end
  if rn_mobs then rn_mobs:setValue(0) end
  if rn_cd then rn_cd:setValue(0) end
  if rn_safe then rn_safe:setChecked(false) end
  cfg.draft.rune.cd = 0
  updateRunePanelLabels()
end

if sp_dist then sp_dist.onValueChange = function() updateSpellPanelLabels() end end
if sp_mana then sp_mana.onValueChange = function() updateSpellPanelLabels() end end
if sp_mobs then sp_mobs.onValueChange = function() updateSpellPanelLabels() end end

if sp_cd then
  sp_cd.onValueChange = function(widget, value)
    local v = tonumber(value)
    if not v and widget and widget.getValue then v = tonumber(widget:getValue()) end
    v = clamp(v or 0, 0, 60000)
    cfg.draft.spell.cd = v
    updateSpellPanelLabels()
  end
end

if rn_dist then rn_dist.onValueChange = function() updateRunePanelLabels() end end
if rn_mobs then rn_mobs.onValueChange = function() updateRunePanelLabels() end end

if rn_cd then
  rn_cd.onValueChange = function(widget, value)
    local v = tonumber(value)
    if not v and widget and widget.getValue then v = tonumber(widget:getValue()) end
    v = clamp(v or 0, 0, 60000)
    cfg.draft.rune.cd = v
    updateRunePanelLabels()
  end
end

local function getSelectedIndex()
  local focused = spellList and spellList:getFocusedChild() or nil
  if not focused then return nil end
  return spellList:getChildIndex(focused)
end

local editingIndex = nil -- index dentro de cfg.actions

local function refreshList()
  if not spellList then return end
  clearChildren(spellList)

  for i, entry in ipairs(cfg.actions) do
    if entry.enabled == nil then entry.enabled = true end
    if entry.safe == nil then entry.safe = false end
    if entry.type ~= "spell" and entry.type ~= "rune" then entry.type = "spell" end

    local row = setupUI(rowTemplate, spellList)
    row.entryIndex = i

    row.enabled:setChecked(entry.enabled and true or false)
    row.enabled.onClick = function()
      entry.enabled = not entry.enabled
      row.enabled:setChecked(entry.enabled)
    end

    row.remove.onClick = function()
      table.remove(cfg.actions, row.entryIndex)
      editingIndex = nil
      refreshList()
    end

    if entry.type == "rune" then
      row.spellName:setText("   ")
      row.spellName:setVisible(true)
      setItemIcon(row.icon, entry.runeId)
      row.icon:setVisible(true)
    else
      row.icon:setVisible(false)
      row.spellName:setVisible(true)
      row.spellName:setColor("orange")
      row.spellName:setText(tostring(entry.spell or ""))
    end

    local dist = tonumber(entry.dist or 0) or 0
    local mobs = tonumber(entry.mobs or 0) or 0
    row.distText:setText(string.format("[%d Sqm Range | ", dist))
    row.mobsText:setText(string.format("+%d Creature]", mobs))

    local safeChar  = entry.safe and "SAFE" or "UNSAFE"
    local safeColor = entry.safe and "#00FF00" or "#FF4040"
    if row.safeText.setColoredText then
      row.safeText:setColoredText({ "[", "white", safeChar, safeColor, "]", "white" })
    else
      row.safeText:setText("[SAFE: " .. safeChar .. "]")
      row.safeText:setColor(safeColor)
    end

    local tip = ""
    if entry.type == "spell" then
      tip = string.format(
        "Spell: %s\nDist: %d\nMobs: %d\nMP: %d\nCD: %ss\nSafe: %s",
        tostring(entry.spell or ""),
        dist,
        mobs,
        tonumber(entry.mana or 0) or 0,
        msToSecText(entry.cd),
        entry.safe and "SAFE" or "UNSAFE"
      )
    else
      tip = string.format(
        "Rune ID: %d\nDist: %d\nMobs: %d\nCD: %ss\nSafe: %s",
        tonumber(entry.runeId or 0) or 0,
        dist,
        mobs,
        msToSecText(entry.cd),
        entry.safe and "SAFE" or "UNSAFE"
      )
    end
    row:setTooltip(tip)

    row.onClick = function(widget)
      spellList:focusChild(widget)
    end

    row.onDoubleClick = function(widget)
      local idx = widget.entryIndex
      local e = cfg.actions[idx]
      if not e then return end
      editingIndex = idx

      if e.type == "rune" then
        if rn_id then rn_id:setText(tostring(e.runeId or "")) end
        if rn_dist then rn_dist:setValue(clamp(e.dist or 1, 0, 12)) end
        if rn_mobs then rn_mobs:setValue(clamp(e.mobs or 0, 0, 10)) end

        local cdv = clamp(tonumber(e.cd or 0) or 0, 0, 60000)
        cfg.draft.rune.cd = cdv
        if rn_cd then rn_cd:setValue(cdv) end
        if rn_cd and rn_cd.onValueChange then pcall(function() rn_cd.onValueChange(rn_cd, cdv) end) end

        if rn_safe then rn_safe:setChecked(e.safe and true or false) end
        updateRunePanelLabels()
        comboInterface:hide()
        rnUI:show(); rnUI:raise(); rnUI:focus()
      else
        if sp_spell then sp_spell:setText(tostring(e.spell or "")) end
        if sp_dist then sp_dist:setValue(clamp(e.dist or 1, 0, 12)) end
        if sp_mana then sp_mana:setValue(clamp(e.mana or 0, 0, 1000)) end
        if sp_mobs then sp_mobs:setValue(clamp(e.mobs or 0, 0, 10)) end

        local cdv = clamp(tonumber(e.cd or 0) or 0, 0, 60000)
        cfg.draft.spell.cd = cdv
        if sp_cd then sp_cd:setValue(cdv) end
        if sp_cd and sp_cd.onValueChange then pcall(function() sp_cd.onValueChange(sp_cd, cdv) end) end

        if sp_safe then sp_safe:setChecked(e.safe and true or false) end
        updateSpellPanelLabels()
        comboInterface:hide()
        spUI:show(); spUI:raise(); spUI:focus()
      end
    end
  end
end

upBtn.onClick = function()
  local idx = getSelectedIndex()
  if not idx or idx < 2 then return end
  cfg.actions[idx], cfg.actions[idx-1] = cfg.actions[idx-1], cfg.actions[idx]
  refreshList()
  local newFocus = spellList:getChildByIndex(idx-1)
  if newFocus then spellList:focusChild(newFocus) end
end

downBtn.onClick = function()
  local idx = getSelectedIndex()
  if not idx or idx >= #cfg.actions then return end
  cfg.actions[idx], cfg.actions[idx+1] = cfg.actions[idx+1], cfg.actions[idx]
  refreshList()
  local newFocus = spellList:getChildByIndex(idx+1)
  if newFocus then spellList:focusChild(newFocus) end
end

if offHealing then
  offHealing:setOn(cfg.main.enabled and true or false)
  offHealing.onClick = function(w) cfg.main.enabled = w:isOn() end
end
if virarTarget then
  virarTarget:setChecked(cfg.main.virarTarget and true or false)
  virarTarget.onCheckChange = function(w) cfg.main.virarTarget = w:isChecked() end
end
if manterDist then
  manterDist:setChecked(cfg.main.manterDist and true or false)
  manterDist.onCheckChange = function(w) cfg.main.manterDist = w:isChecked() end
end
if checkStairs then
  checkStairs:setChecked(cfg.main.checkStairs and true or false)
  checkStairs.onCheckChange = function(w) cfg.main.checkStairs = w:isChecked() end
end
if ignoreParty then
  ignoreParty:setChecked(cfg.main.ignoreParty and true or false)
  ignoreParty.onCheckChange = function(w) cfg.main.ignoreParty = w:isChecked() end
end
if stopOnPk then
  stopOnPk:setChecked(cfg.main.stopOnPk and true or false)
  stopOnPk.onCheckChange = function(w) cfg.main.stopOnPk = w:isChecked() end
end
if sqmSafe then
  sqmSafe:setValue(clamp(cfg.main.sqmSafe, 1, 10))
  sqmSafe.onValueChange = function(w, v)
    cfg.main.sqmSafe = clamp(v, 1, 10)
    w:setValue(cfg.main.sqmSafe)
  end
end

addSpellBtn.onClick = function()
  editingIndex = nil
  resetSpellForm()
  spUI:show(); spUI:raise(); spUI:focus()
  comboInterface:hide()
end

addRuneBtn.onClick = function()
  editingIndex = nil
  resetRuneForm()
  rnUI:show(); rnUI:raise(); rnUI:focus()
  comboInterface:hide()
end

sp_cancel.onClick = function() spUI:hide() comboInterface:show() end
rn_cancel.onClick = function() rnUI:hide() comboInterface:show() end

sp_add.onClick = function()
  local spell = trim(sp_spell and sp_spell:getText() or "")
  if isEmpty(spell) then return warn("[Combo] Preencha o campo SPELL.") end

  local entry = {
    type    = "spell",
    enabled = true,
    spell   = spell,
    dist    = clamp(sp_dist and sp_dist:getValue() or 1, 0, 12),
    mana    = clamp(sp_mana and sp_mana:getValue() or 0, 0, 1000),
    mobs    = clamp(sp_mobs and sp_mobs:getValue() or 0, 0, 10),
    cd      = clamp((cfg.draft and cfg.draft.spell and cfg.draft.spell.cd) or (sp_cd and sp_cd:getValue()) or 0, 0, 60000),
    safe    = (sp_safe and sp_safe:isChecked()) or false
  }

  if editingIndex and cfg.actions[editingIndex] then
    entry.enabled = cfg.actions[editingIndex].enabled ~= false
    cfg.actions[editingIndex] = entry
  else
    table.insert(cfg.actions, entry)
  end

  refreshList()
  editingIndex = nil
  resetSpellForm()
  spUI:hide()
  comboInterface:show()
end

rn_add.onClick = function()
  local runeId = tonumber(trim(rn_id and rn_id:getText() or ""))
  if not runeId or runeId <= 0 then return warn("[Combo] ID da runa invalido.") end

  local entry = {
    type    = "rune",
    enabled = true,
    runeId  = runeId,
    dist    = clamp(rn_dist and rn_dist:getValue() or 1, 0, 12),
    mana    = 0,
    mobs    = clamp(rn_mobs and rn_mobs:getValue() or 0, 0, 10),
    cd      = clamp((cfg.draft and cfg.draft.rune and cfg.draft.rune.cd) or (rn_cd and rn_cd:getValue()) or 0, 0, 60000),
    safe    = (rn_safe and rn_safe:isChecked()) or false
  }

  if editingIndex and cfg.actions[editingIndex] then
    entry.enabled = cfg.actions[editingIndex].enabled ~= false
    cfg.actions[editingIndex] = entry
  else
    table.insert(cfg.actions, entry)
  end

  refreshList()
  editingIndex = nil
  resetRuneForm()
  rnUI:hide()
  comboInterface:show()
end

spUI:hide()
rnUI:hide()
resetSpellForm()
resetRuneForm()
updateSpellPanelLabels()
updateRunePanelLabels()
refreshList()

local function resetRuntimeCooldowns()
  if cfg and cfg.actions then
    for _, a in ipairs(cfg.actions) do
      a.nextCast = 0
    end
  end
  userRune = 0
end

resetRuntimeCooldowns()

-- quando troca de char / reconecta
if g_game and connect then
  connect(g_game, {
    onGameStart = function()
      resetRuntimeCooldowns()
    end
  })
end

local function showMessage(msg)
    if modules and modules.game_textmessage and modules.game_textmessage.displayGameMessage then
      modules.game_textmessage.displayGameMessage(msg)
    end
  end

cfg.main.disabledByFrag = cfg.main.disabledByFrag or {} -- lista de indices desligados
local skullDropAt = 0

local function iAmFrag()
  local p = g_game.getLocalPlayer()
  if not p then return false end
  local skull = p.getSkull and p:getSkull() or 0
  return skull >= 3
end

local function iAmDead()
  local p = g_game.getLocalPlayer()
  if not p then return false end
  if p.getHealthPercent then
    return (p:getHealthPercent() or 100) <= 0
  end
  return false
end

local function disableUnsafeActions()
  local did = false
  -- evita duplicar indices
  local mark = {}
  for _, idx in ipairs(cfg.main.disabledByFrag) do mark[idx] = true end

  for i, a in ipairs(cfg.actions or {}) do
    if a and a.enabled ~= false and a.safe == false then
      a.enabled = false
      if not mark[i] then
        table.insert(cfg.main.disabledByFrag, i)
        mark[i] = true
      end
      did = true
    end
  end

  if did and type(refreshList) == "function" then refreshList() end
  if did then showMessage("[LNS-SCRIPT] PK/FRAG Detectado - SPELLS UNSAFE DESLIGADAS!") end
end

local function restoreUnsafeActions()
  if type(cfg.main.disabledByFrag) ~= "table" or #cfg.main.disabledByFrag == 0 then return end

  for _, idx in ipairs(cfg.main.disabledByFrag) do
    local a = cfg.actions and cfg.actions[idx]
    if a then a.enabled = true end
  end

  cfg.main.disabledByFrag = {}
  skullDropAt = 0

  if type(refreshList) == "function" then refreshList() end
  showMessage("[LNS-SCRIPT] PK Expirado - SPELLS UNSAFE RELIGADAS.")
end

macro(200, function()
  if not storage[switchCombo].enabled then return end
  if not ui or not ui.stopOnPk or not ui.stopOnPk.isChecked then return end

  if not ui.stopOnPk:isChecked() then
    restoreUnsafeActions()
    return
  end

  local frag = iAmFrag()

  if frag and (#cfg.main.disabledByFrag == 0) then
    disableUnsafeActions()
    skullDropAt = 0
    return
  end

  -- se já desligou, espera ficar safe pra restaurar (ou morte)
  if #cfg.main.disabledByFrag > 0 then
    if iAmDead() then
      restoreUnsafeActions()
      return
    end

    if frag then
      skullDropAt = 0
    else
      if skullDropAt == 0 then skullDropAt = os.time() end
      -- pode restaurar imediatamente ao perder skull
      if os.time() >= skullDropAt then
        restoreUnsafeActions()
      end
    end
  end
end)

restoreUnsafeActions()

local cdSpell = { active=false, spell="", lastTime=0 }

local function stopSpellCalc()
  cdSpell.active = false
  cdSpell.spell = ""
  cdSpell.lastTime = 0
end

macro(100, function()
  if not cdSpell.active then return end
  if cdSpell.spell == "" then stopSpellCalc(); return end
  say(cdSpell.spell)
end)

onTalk(function(name, level, mode, text)
  if not cdSpell.active then return end
  local player = g_game.getLocalPlayer()
  if not player then return end
  if name ~= player:getName() then return end

  local msg = trim(text):lower()
  local expected = trim(cdSpell.spell):lower()
  if expected == "" or msg ~= expected then return end

  local t = nowMs()
  if cdSpell.lastTime > 0 then
    local cd = math.floor(t - cdSpell.lastTime)
    local v = clamp(cd, 0, 60000)

    if sp_cd and sp_cd.setValue then
      sp_cd:setValue(v)
      cfg.draft.spell.cd = v
      if sp_cd.onValueChange then pcall(function() sp_cd.onValueChange(sp_cd, v) end) end
    else
      cfg.draft.spell.cd = v
      updateSpellPanelLabels()
    end

    warn(string.format("[CD-SPELL] %d ms (%.1fs)", v, v/1000))
    stopSpellCalc()
  else
    cdSpell.lastTime = t
  end
end)

if sp_calcBtn then
  sp_calcBtn.onClick = function()
    local spell = trim(sp_spell and sp_spell:getText() or "")
    if spell == "" then return end
    cdSpell.active = true
    cdSpell.spell = spell
    cdSpell.lastTime = 0
  end
end

cfg.draft = cfg.draft or {}
cfg.draft.rune = cfg.draft.rune or { cd = 0 }

local runeCd = {
  active    = false,
  runeId    = 0,
  missileId = nil,
  lastTime  = 0
}

local function nowMs()
  if now then return now end
  return (os.time() * 1000) + math.floor((os.clock() * 1000) % 1000)
end

local function stopRuneCd()
  runeCd.active = false
  runeCd.runeId = 0
  runeCd.missileId = nil
  runeCd.lastTime = 0
end

local function applyRuneCd(ms)
  ms = math.floor(tonumber(ms) or 0)
  if ms < 0 then ms = 0 end
  if ms > 60000 then ms = 60000 end

  cfg.draft.rune.cd = ms

  local rn_cd = runeAddPanel and W(runeAddPanel, "cooldown")
  if rn_cd and rn_cd.setValue then
    rn_cd:setValue(ms)
  end

  if type(updateRunePanelLabels) == "function" then
    updateRunePanelLabels()
  end

  warn(string.format("[CD-RUNE] %d ms (%.1fs)", ms, ms / 1000))
  stopRuneCd()
end

local function tryUseRune(runeId)
  local target = g_game.getAttackingCreature()
  if not target then target = g_game.getLocalPlayer() end
  if not target then return false end

  if type(useWith) ~= "function" then
    warn("[CD-RUNE] useWith() nao existe no seu client.")
    return false
  end

  local ok = pcall(function()
    useWith(runeId, target)
  end)

  return ok
end

local runeAuto = {
  active = false,
  runeId = 0,
  stage = 0,       -- 1=forcar 1o missile, 2=forcar 2o missile
  nextAt = 0,
  startedAt = 0
}

local function startAutoRune2x(runeId)
  runeAuto.active = true
  runeAuto.runeId = tonumber(runeId) or 0
  runeAuto.stage = 1
  runeAuto.nextAt = 0
  runeAuto.startedAt = nowMs()
end

macro(60, function()
  if not runeAuto.active then return end
  if runeAuto.runeId <= 0 then runeAuto.active = false; return end

  if not runeCd.active then runeAuto.active = false; return end

  local t = nowMs()

  if t - runeAuto.startedAt > 20000 then
    warn("[CD-RUNE] Timeout: nao consegui medir (sem 2 missiles).")
    runeAuto.active = false
    return
  end

  if runeAuto.nextAt ~= 0 and t < runeAuto.nextAt then return end

  runeAuto.nextAt = t + 250

  if runeAuto.stage == 1 then
    tryUseRune(runeAuto.runeId)
    return
  end

  if runeAuto.stage == 2 then
    tryUseRune(runeAuto.runeId)
    return
  end
end)

local function handleRuneMissile(missile)
  if not runeCd.active or not missile then return end

  local player = g_game.getLocalPlayer()
  if not player then return end

  local src = missile:getSource()
  if not src then return end

  local tile = g_map.getTile(src)
  if not tile then return end

  local creatures = tile:getCreatures() or {}
  if #creatures == 0 then return end

  local caster = creatures[1]
  if caster:getName() ~= player:getName() then return end

  local mid = missile:getId()
  if not mid then return end

  local t = nowMs()

  if not runeCd.missileId then
    runeCd.missileId = mid
    runeCd.lastTime = t

    if runeAuto.active then
      runeAuto.stage = 2
      runeAuto.nextAt = 0
    end
    return
  end

  if mid ~= runeCd.missileId then return end

  if runeCd.lastTime > 0 then
    applyRuneCd(t - runeCd.lastTime)
    -- applyRuneCd -> stopRuneCd() -> runner para sozinho
  end
end

if type(onMissile) == "function" then
  pcall(function()
    onMissile(handleRuneMissile)
  end)
end

if type(onMissle) == "function" then
  pcall(function()
    onMissle(handleRuneMissile)
  end)
end

if g_map and connect then
  pcall(function()
    connect(g_map, {
      onMissile = function(_, missile)
        handleRuneMissile(missile)
      end
    })
  end)
end

do
  local btn = runeAddPanel and W(runeAddPanel, "calculeCooldown")
  if btn then
    btn.onClick = function()
      local rn_id = runeAddPanel and W(runeAddPanel, "runa")
      local runeId = tonumber(trim(rn_id and rn_id:getText() or ""))

      if not runeId or runeId <= 0 then
        return warn("[CD-RUNE] ID da runa inválido.")
      end

      stopRuneCd()
      runeCd.active = true
      runeCd.runeId = runeId

      -- [INSERIDO] força 2 usos (via tentativas + missile)
      startAutoRune2x(runeId)

      warn("[CD-RUNE] Aguardando missile...")
    end
  end
end

do
  local rn_cd = runeAddPanel and W(runeAddPanel, "cooldown")
  if rn_cd and rn_cd.setValue then
    rn_cd:setValue(tonumber(cfg.draft.rune.cd) or 0)
    if type(updateRunePanelLabels) == "function" then
      updateRunePanelLabels()
    end
  end
end

ANDAR_NAO_SAFE = false

local function buildIdLookup(ids)
  local t = {}
  if type(ids) ~= "table" then return t end
  for _, v in pairs(ids) do
    local id = nil
    if type(v) == "table" then
      id = (v.getId and v:getId()) or v.id
    else
      id = v
    end
    id = tonumber(id)
    if id then t[id] = true end
  end
  return t
end

local function checkStairsNearby(dist, idLookup)
  local player = g_game.getLocalPlayer()
  if not player then return false end
  local p = player:getPosition()
  if not p then return false end

  for x = -dist, dist do
    for y = -dist, dist do
      local tile = g_map.getTile({ x = p.x + x, y = p.y + y, z = p.z })
      if tile then
        for _, item in ipairs(tile:getItems() or {}) do
          if idLookup[item:getId()] then
            return true
          end
        end
      end
    end
  end
  return false
end

macro(200, function()
  if not ui or not ui.CheckStairs then ANDAR_NAO_SAFE = false return end
  if not ui.CheckStairs:isChecked() then ANDAR_NAO_SAFE = false return end

  local dist = clamp((cfg and cfg.main and cfg.main.sqmSafe) or 8, 1, 10)
  local ids = (cfg and cfg.main and cfg.main.safeIdsAndares) or {}
  local lookup = buildIdLookup(ids)

  ANDAR_NAO_SAFE = checkStairsNearby(dist, lookup)
end)

macro(300, function()
  local player = g_game.getLocalPlayer()
  if not player then return end
  if ANDAR_NAO_SAFE then
    player:setText("UNSAFE")
  else
    player:setText("")
  end
end)

PLAYERSINSCREEN = false

macro(200, function()
  if not ui or not ui.IgnoreParty or not ui.IgnoreParty.isChecked then
    PLAYERSINSCREEN = false
    return
  end

  local player = g_game.getLocalPlayer()
  if not player then return end

  if not ui.IgnoreParty:isChecked() then
    PLAYERSINSCREEN = false
    return
  end

  local range = 8
  if cfg and cfg.main then
    range = clamp(cfg.main.sqmSafe, 1, 10)
  elseif ui.sqmSafe and ui.sqmSafe.getValue then
    range = clamp(ui.sqmSafe:getValue(), 1, 10)
  end

  local foundEnemy = false
  local spectators = getSpectators() or {}

  for _, spec in ipairs(spectators) do
    if spec and spec:isPlayer() and not spec:isLocalPlayer() then
      local dist = getDistanceBetween(player:getPosition(), spec:getPosition())
      if dist <= range then
        if not (spec:isPartyMember() or (spec.getShield and spec:getShield() > 0)) then
          if not (spec.getEmblem and spec:getEmblem() == 1) then
            foundEnemy = true
            break
          end
        end
      end
    end
  end

  PLAYERSINSCREEN = foundEnemy

end)

local lastMove = 0
local moveDelay = 25
local lastDir = nil
local stableUntil = 0

local function chebyshevDist(a, b)
  return math.max(math.abs(a.x - b.x), math.abs(a.y - b.y))
end

local function stepPos(p, dir)
  local n = {x = p.x, y = p.y, z = p.z}
  if dir == 0 then n.y = n.y - 1
  elseif dir == 1 then n.x = n.x + 1
  elseif dir == 2 then n.y = n.y + 1
  elseif dir == 3 then n.x = n.x - 1
  elseif dir == 4 then n.x = n.x + 1; n.y = n.y - 1
  elseif dir == 5 then n.x = n.x + 1; n.y = n.y + 1
  elseif dir == 6 then n.x = n.x - 1; n.y = n.y + 1
  elseif dir == 7 then n.x = n.x - 1; n.y = n.y - 1
  end
  return n
end

local function isWalkableFree(pos)
  local tile = g_map.getTile(pos)
  if not tile or not tile:isWalkable() then return false end
  local cr = tile:getCreatures() or {}
  return #cr == 0
end

macro(200, function()
  if not ui or not ui.manterDist or not ui.manterDist.isChecked then return end
  if not (storage[switchCombo].enabled and ui.manterDist:isChecked()) then return end

  local target = g_game.getAttackingCreature()
  if not target then return end

  local player = g_game.getLocalPlayer()
  if not player then return end

  local pPos = player:getPosition()
  local tPos = target:getPosition()
  if not pPos or not tPos or pPos.z ~= tPos.z then return end

  local nowt = nowMs()
  if nowt - lastMove < moveDelay then return end

  local dist = chebyshevDist(pPos, tPos)
  local desiredDist = 4

  if dist <= 1 then
    local bestDir, bestScore = -1, -999999
    for dir = 0, 7 do
      local np = stepPos(pPos, dir)
      if isWalkableFree(np) then
        local newDist = chebyshevDist(np, tPos)
        local score = newDist * 10
        if dir <= 3 then score = score + 2 else score = score - 1 end
        if lastDir and ((dir + 2) % 4 == lastDir) then score = score - 8 end
        if lastDir and dir == lastDir then score = score + 3 end
        if newDist >= 2 then score = score + 5 end
        if score > bestScore then
          bestScore = score
          bestDir = dir
        end
      end
    end

    if bestDir ~= -1 then
      if player:isAutoWalking() then player:stopAutoWalk() end
      g_game.walk(bestDir)
      lastDir = bestDir
      lastMove = nowt
      stableUntil = nowt + 400
    end
    return
  end

  if dist > desiredDist then
    if nowt < stableUntil then return end
    if not player:isAutoWalking() then
      g_game.autoWalk(tPos, { precision = desiredDist - 1, ignoreNonPathable = true })
      lastMove = nowt
      stableUntil = nowt + 350
    end
    lastDir = nil
    return
  end

  if nowt > stableUntil then lastDir = nil end
end)

local lastTurn = 0
local turnDelay = 20

local function getDir4(fromPos, toPos)
  local dx = toPos.x - fromPos.x
  local dy = toPos.y - fromPos.y
  if dx == 0 and dy == 0 then return nil end
  if math.abs(dx) > math.abs(dy) then
    return (dx > 0) and 1 or 3
  else
    return (dy > 0) and 2 or 0
  end
end

macro(30, function()
  if not (storage[switchCombo].enabled and comboInterface.virarTarget:isChecked()) then return end

  local player = g_game.getLocalPlayer()
  if not player then return end

  local target = g_game.getAttackingCreature()
  if not target then return end

  local pPos = player:getPosition()
  local tPos = target:getPosition()
  if not pPos or not tPos or pPos.z ~= tPos.z then return end

  local nowt = nowMs()
  if nowt - lastTurn < turnDelay then return end

  local dir = getDir4(pPos, tPos)
  if not dir then return end

  local curDir = player.getDirection and player:getDirection() or nil
  if curDir ~= nil and curDir == dir then return end

  if turn then
    turn(dir)
  elseif g_game.turn then
    g_game.turn(dir)
  end

  lastTurn = nowt
end)

local runeToMissile = {
    [3155] = 32,  -- SD
    [3175] = 20,
    [3191] = 4,
    [3161] = 22,
    [3202] = 25
}

onTalk(function(name, level, mode, text, channelId, pos)
    if name ~= g_game.getLocalPlayer():getName() then return end
    text = text:lower()
    
    -- Varre sua lista de ações para ver se o que você falou é uma magia do combo
    if cfg and cfg.actions then
        for _, action in ipairs(cfg.actions) do
            if action.enabled and action.type == "spell" and action.spell:lower() == text then
                -- Aplica o cooldown REAL configurado na action + tempo atual
                action.nextCast = now + (action.cd or 1000)
            end
        end
    end
end)

onMissle(function(missle)
    local player = g_game.getLocalPlayer()
    if not player then return end

    local src = missle:getSource()
    
    -- Verifica se o míssil saiu do mesmo SQM que o player está
    -- (Método mais leve e rápido que getCreatures)
    local pPos = player:getPosition()
    if src.z ~= pPos.z or src.x ~= pPos.x or src.y ~= pPos.y then return end

    local missleId = missle:getId()

    -- Varre a lista para achar qual runa tem esse efeito de tiro
    if cfg and cfg.actions then
        for _, action in ipairs(cfg.actions) do
            if action.enabled and action.type == "rune" then
                local rId = tonumber(action.runeId)
                -- Se o ID do míssil bater com o ID mapeado da runa
                if rId and runeToMissile[rId] == missleId then
                    -- Aplica o cooldown REAL configurado na action
                    userRune = now + (action.cd or 1000)
                end
            end
        end
    end
end)

local SPAM_DELAY = 50 -- Tempo de espera "provisório" até o servidor responder

macro(100, function()
    if not storage[switchCombo].enabled then return end
    if not cfg.main.enabled then return end 

    local player = g_game.getLocalPlayer()
    local target = g_game.getAttackingCreature()
    
    if not player or not target then return end
    if player:isNpc() then return end

    if cfg.main.stopOnPk and target:isPlayer() then return end

    local pPos = player:getPosition()
    local tPos = target:getPosition()
    
    if not pPos or not tPos or pPos.z ~= tPos.z then return end

    local dist = math.max(math.abs(pPos.x - tPos.x), math.abs(pPos.y - tPos.y))

    for i, action in ipairs(cfg.actions) do
        if action.enabled then
            
            -- 1. Checagem de Cooldown (Baseada no onTalk/onMissle)
            -- Se 'nextCast' não existir, assume que está pronto (0)
            local isReady = now >= (action.nextCast or 0)

            -- 2. Checagens de Distância e Mana
            local distOk = dist <= (action.dist or 8)
            
            local manaOk = true
            if action.type == "spell" then
                local needMana = tonumber(action.mana) or 0
                if mana() < needMana then manaOk = false end
            end

            local mobsOk = true
            if (action.mobs or 0) > 0 then
                local count = 0
                local specs = g_map.getSpectators(pPos, false)
                for _, s in ipairs(specs) do
                    if s:isMonster() then
                        local sPos = s:getPosition()
                        local sd = math.max(math.abs(pPos.x - sPos.x), math.abs(pPos.y - sPos.y))
                        if sd <= 7 then count = count + 1 end
                    end
                end
                if count < action.mobs then mobsOk = false end
            end

            -- 4. LÓGICA SAFE (Safe Checkbox)
            -- Checkbox MARCADO = SAFE (Pode usar sempre)
            -- Checkbox DESMARCADO = UNSAFE (Verifica perigos)
            local safeOk = true
            
            if not action.safe then -- Se for magia PERIGOSA
                -- Verifica variáveis globais (que vem do seu outro script)
                if cfg.main.checkStairs and ANDAR_NAO_SAFE then safeOk = false end
                if cfg.main.checkPlayers and PLAYERSINSCREEN then safeOk = false end
            end

            if isReady and distOk and manaOk and mobsOk and safeOk then
                
                if action.type == "spell" then
                    say(action.spell)
                    delay(2000)
                    action.nextCast = now + SPAM_DELAY 
                    return 

                elseif action.type == "rune" then
                    local rid = tonumber(action.runeId)
                    if rid and rid > 0 then
                      if (not userRune or userRune <= now) then
                        useWith(rid, target) 
                      end
                      return
                    end
                end
            end
        end
    end
end)
